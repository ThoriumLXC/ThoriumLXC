{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Material for MkDocs","text":"<p>Welcome to Material for MkDocs.</p>"},{"location":"cmangos-classic/client-data/","title":"Client Data","text":"<p>CMangos relies on client data to accurately represent the virtual world's physical environment. This data includes critical details such as terrain heights, road layouts, object positioning, and other environmental features. It enables the server to make informed decisions, especially when it comes to NPC pathfinding, collision detection, and other mechanics that depend on the spatial layout of the game world.</p>"},{"location":"cmangos-classic/client-data/#what-is-client-data","title":"What is Client Data?","text":"<p>Client data refers to information about the virtual world\u2019s structure, including:</p> <ul> <li>Terrain Heights: The elevation of hills, valleys, and flatlands.</li> <li>Road Networks: Pathways and roads that guide NPCs and players.</li> <li>Object Positioning: The placement of static objects like buildings, trees, and other world assets.</li> </ul> <p>This data is not pre-baked into the server code. Instead, the server relies on external files generated from the game client to understand the world\u2019s geography. Without this data, the server would lack context for NPC movement, environmental interactions, and spatial awareness.</p>"},{"location":"cmangos-classic/client-data/#why-client-data-is-important","title":"Why Client Data is Important","text":"<p>The extracted client data allows the server to:</p> <ul> <li>Improve NPC Pathfinding: NPCs can navigate complex terrain more realistically.</li> <li>Handle Collisions Accurately: Ensures characters and objects behave correctly when interacting with the environment.</li> <li>Optimize Server Performance: Reduces the need for complex runtime calculations by referencing pre-processed data.</li> </ul>"},{"location":"cmangos-classic/client-data/#how-client-data-is-extracted","title":"How Client Data is Extracted","text":"<p>The extraction process involves analyzing the game client files to pull out relevant data, such as height maps and 3D models. This is done using tools provided within the CMangos Docker setup.</p>"},{"location":"cmangos-classic/client-data/#steps-to-extract-client-data","title":"Steps to Extract Client Data","text":"<ol> <li> <p>Prepare Your Game Client:    Ensure you have a compatible version of the World of Warcraft client. The client version must match the CMangos server version you're working with.</p> </li> <li> <p>Mount the Client Directory:    Using Docker, mount the directory containing your game client into a Docker volume. This makes the client\u2019s data accessible to the extraction tools.</p> </li> </ol> <p>Example:    <pre><code>docker volume create cmangos-client-data\ndocker run -v /path/to/client:/client -v cmangos-client-data:/data cmangos/tools extract\n</code></pre></p> <p>In this example:    - <code>/path/to/client</code> is the path to your local game client files.    - <code>cmangos-client-data</code> is the Docker volume where the extracted data will be stored.</p> <ol> <li> <p>Run the Extraction Tool:    The <code>extract</code> tool scans the client\u2019s data, processes the models, height maps, and other files, and populates the Docker volume with the necessary data.</p> </li> <li> <p>Verify the Extraction:    After the process completes, check the <code>/data</code> volume to ensure the data has been successfully extracted.</p> </li> </ol>"},{"location":"cmangos-classic/client-data/#using-extracted-client-data","title":"Using Extracted Client Data","text":"<p>Once the client data has been extracted:</p> <ul> <li>The Docker volume containing the data will be automatically mounted when you bring up the CMangos server with <code>docker-compose up</code>.</li> <li>The server will reference this data for tasks like NPC movement, environmental interactions, and collision detection\u2014without requiring any additional setup from you.</li> </ul> <p>This approach ensures that the server can manage world data seamlessly, reducing the need for complex manual configurations.</p>"},{"location":"cmangos-classic/client-data/#summary","title":"Summary","text":"<ul> <li>Client Data represents the physical layout of the game world (terrain, objects, roads).</li> <li>The data is extracted from the game client using Docker-based tools.</li> <li>Docker volumes simplify the process by storing extracted data for easy reuse.</li> <li>The server uses this data automatically during runtime to improve pathfinding, collision detection, and world interaction logic.</li> </ul> <p>By following this process, you ensure that your CMangos server has accurate, detailed knowledge of the game world, enhancing gameplay quality and server performance.</p>"},{"location":"cmangos-classic/clients/","title":"Supported Clients","text":"<p>CMangos is designed to work with specific versions of the World of Warcraft client. The following list includes the environments where CMangos has been tested and confirmed to work reliably. While it may function on other versions or setups, these are the officially supported clients for the best experience.</p>"},{"location":"cmangos-classic/clients/#supported-world-of-warcraft-clients","title":"Supported World of Warcraft Clients","text":"Version Expansion Build Number Status 1.12.1 Classic 5875 \u2705 Supported <p>Note: Only full, unmodified clients are supported. Custom clients or repacks may cause compatibility issues.</p>"},{"location":"cmangos-classic/clients/#compatibility-notes","title":"Compatibility Notes","text":"<ul> <li> <p>Localization:   CMangos supports clients in various languages, but core functionality is tested primarily on English clients.</p> </li> <li> <p>Patches &amp; Updates:   Ensure your client matches the exact supported build number. Partial updates or mismatched patches may lead to instability.</p> </li> <li> <p>Legacy Clients:   While older clients may connect, features and stability cannot be guaranteed outside the supported versions listed above.</p> </li> </ul>"},{"location":"cmangos-classic/clients/#system-requirements-for-clients","title":"System Requirements for Clients","text":"<p>Although CMangos itself runs in Docker, the World of Warcraft client has its own requirements depending on the version. Here\u2019s a general guideline:</p> <ul> <li> <p>Operating Systems:   Windows XP, Windows 7, Windows 10 (for older clients, compatibility mode may be required)   macOS (for older PowerPC or Intel-based versions)</p> </li> <li> <p>Hardware:   Minimal requirements based on the client version. Modern systems will easily exceed these requirements.</p> </li> </ul>"},{"location":"cmangos-classic/clients/#known-issues-with-unsupported-clients","title":"Known Issues with Unsupported Clients","text":"<ul> <li>Connection instability</li> <li>Broken NPC pathfinding</li> <li>UI inconsistencies</li> <li>Incompatible database interactions</li> </ul> <p>For the best results, always use one of the supported client versions listed above.</p>"},{"location":"cmangos-classic/overview/","title":"cMaNGOS Classic","text":"<p>Welcome to the CMangos Getting Started guide. This section will walk you through the process of setting up your CMangos server using Docker. Whether you're new to server emulation or Docker itself, this guide is designed to help you get up and running quickly and smoothly.</p>"},{"location":"cmangos-classic/overview/#1-prerequisites","title":"1. Prerequisites","text":"<p>Before you begin, make sure you have the following installed on your system:</p> <ul> <li> <p>Docker: Required to run the CMangos server in isolated containers.   Download Docker</p> </li> <li> <p>Docker Compose: Simplifies the process of managing multi-container Docker applications.   Learn about Docker Compose</p> </li> <li> <p>Git (optional but recommended): Helps clone the CMangos repository easily.   Get Git</p> </li> </ul>"},{"location":"cmangos-classic/overview/#2-cloning-the-cmangos-repository","title":"2. Cloning the CMangos Repository","text":"<p>You'll need to download the CMangos Docker configuration files. The easiest way to do this is by cloning the repository:</p> <pre><code>git clone https://github.com/your-cmangos-repo.git\ncd your-cmangos-repo\n</code></pre> <p>If you prefer not to use Git, you can also download the repository as a ZIP file from GitHub and extract it.</p>"},{"location":"cmangos-classic/overview/#3-understanding-the-project-structure","title":"3. Understanding the Project Structure","text":"<p>After downloading the repository, you\u2019ll see a few important files and folders:</p> <ul> <li><code>docker-compose.yml</code>: Defines how the CMangos server and its database are run using Docker.</li> <li><code>configs/</code>: Holds configuration files like <code>mangosd.conf</code> and <code>realmd.conf</code>.</li> <li><code>data/</code>: Where map data and client files will be stored.</li> <li><code>logs/</code>: For server logs to help with diagnostics and troubleshooting.</li> </ul>"},{"location":"cmangos-classic/overview/#4-configuring-the-server-optional","title":"4. Configuring the Server (Optional)","text":"<p>Before starting the server, you can adjust settings in the configuration files if needed:</p> <ul> <li><code>configs/mangosd.conf</code>: Controls gameplay mechanics, server rates, and more.</li> <li><code>configs/realmd.conf</code>: Manages login server settings.</li> </ul> <p>You can modify these files using any text editor. If you\u2019re unsure about changes, the default settings will work fine to start.</p>"},{"location":"cmangos-classic/overview/#5-starting-the-server","title":"5. Starting the Server","text":"<p>Once everything is set up, start the server using Docker Compose:</p> <pre><code>docker-compose up -d\n</code></pre> <p>This command will:</p> <ul> <li>Pull the necessary Docker images (if not already downloaded).</li> <li>Start both the CMangos server and the database in the background.</li> </ul> <p>To verify that everything is running:</p> <pre><code>docker-compose ps\n</code></pre> <p>You should see services like <code>mangosd</code> and <code>realmd</code> listed as \"Up.\"</p>"},{"location":"cmangos-classic/overview/#6-connecting-to-your-server","title":"6. Connecting to Your Server","text":"<ol> <li>Launch your World of Warcraft client (compatible with the server version).</li> <li>Edit the <code>realmlist.wtf</code> file in your client\u2019s directory to point to your server:</li> </ol> <pre><code>set realmlist 127.0.0.1\n</code></pre> <ol> <li>Save the file and start the game.</li> </ol> <p>You\u2019ll need to create an account to log in:</p> <pre><code>docker-compose exec mangosd account create username password\n</code></pre> <p>Replace <code>username</code> and <code>password</code> with your preferred credentials.</p>"},{"location":"cmangos-classic/overview/#7-managing-the-server","title":"7. Managing the Server","text":"<p>Here are some common Docker Compose commands to manage your CMangos server:</p> <ul> <li> <p>View server logs: <pre><code>docker-compose logs -f\n</code></pre></p> </li> <li> <p>Stop the server: <pre><code>docker-compose down\n</code></pre></p> </li> <li> <p>Restart the server: <pre><code>docker-compose restart\n</code></pre></p> </li> <li> <p>Update the server to the latest version: <pre><code>docker-compose pull\ndocker-compose up -d\n</code></pre></p> </li> </ul>"},{"location":"cmangos-classic/overview/#8-troubleshooting-tips","title":"8. Troubleshooting Tips","text":"<ul> <li> <p>Check for Errors:   If the server doesn\u2019t start correctly, use <code>docker-compose logs</code> to review the output for errors.</p> </li> <li> <p>Database Issues:   Ensure the database container (<code>db</code>) is running using <code>docker-compose ps</code>.</p> </li> <li> <p>Port Conflicts:   Make sure ports used by CMangos (default: 3724 for login, 8085 for the game server) are not in use by other applications.</p> </li> </ul>"},{"location":"cmangos-classic/overview/#9-next-steps","title":"9. Next Steps","text":"<p>After you\u2019re comfortable with the basics, you can explore:</p> <ul> <li>Customizing Server Settings in <code>mangosd.conf</code> for gameplay tweaks.</li> <li>Managing Accounts with in-game commands or the database.</li> <li>Advanced Configuration for multiple realms or remote access.</li> </ul> <p>For more details, check out the other sections of the documentation, including Installation, Configuration, and Database Management.</p> <p>With this guide, you should now have a fully functional CMangos server running in Docker. Enjoy your journey into Azeroth!</p>"},{"location":"cmangos-classic/versions/","title":"Versions","text":"<p>CMangos Docker images are published using a versioning system called CalVer. This section explains how the CalVer format works, how to use these versions in your Docker Compose setup, and where to find the images across different container registries.</p>"},{"location":"cmangos-classic/versions/#what-is-calver","title":"What is CalVer?","text":"<p>CalVer stands for \"Calendar Versioning\". It\u2019s a simple, easy-to-understand versioning format designed to help you know exactly when an image was created and if there have been any updates to it.</p>"},{"location":"cmangos-classic/versions/#calver-format","title":"CalVer Format:","text":"<pre><code>YYYY.MM.DD-R\n</code></pre> <ul> <li><code>YYYY</code> - The year the image was published.</li> <li><code>MM</code> - The month of publication.</li> <li><code>DD</code> - The day the image was created.</li> <li><code>R</code> - The revision number for that day. If changes are made to the image on the same day, this number increases.</li> </ul>"},{"location":"cmangos-classic/versions/#example","title":"Example:","text":"<pre><code>2024.02.03-1\n</code></pre> <ul> <li>2024 - Published in the year 2024</li> <li>02 - In February</li> <li>03 - On the 3rd day of the month</li> <li>-1 - This is the first version released on that day</li> </ul> <p>If the image was updated later the same day, it would be:</p> <pre><code>2024.02.03-2\n</code></pre> <p>This system makes it easy to track when an image was last updated and if any quick fixes or patches were applied on the same day.</p>"},{"location":"cmangos-classic/versions/#using-calver-versions-in-docker-compose","title":"Using CalVer Versions in Docker Compose","text":"<p>To use a specific CMangos image version in your <code>docker-compose.yml</code>, you\u2019ll reference the CalVer tag like this:</p> <pre><code>version: \"3.8\"\nservices:\n  cmangos-server:\n    image: mockorg/cmangos:2024.02.03-1\n    ports:\n      - \"8085:8085\"\n      - \"3724:3724\"\n    volumes:\n      - cmangos-data:/data\n    environment:\n      - SERVER_CONFIG=/configs/mangosd.conf\n\nvolumes:\n  cmangos-data:\n</code></pre> <p>In this example:</p> <ul> <li><code>mockorg/cmangos</code> is the mock organization and repository name.</li> <li><code>2024.02.03-1</code> is the specific CalVer version tag.</li> </ul> <p>If you want to always pull the latest image, you can use:</p> <pre><code>image: mockorg/cmangos:latest\n</code></pre> <p>However, using a specific CalVer version is recommended for stability, so you always know exactly which version is running.</p>"},{"location":"cmangos-classic/versions/#where-to-find-cmangos-images","title":"Where to Find CMangos Images","text":"<p>You can find CMangos Docker images hosted on popular container registries. Here are mock links to give you an idea of where they would be available:</p> <ul> <li>Docker Hub</li> <li>GitHub Container Registry</li> <li>GitLab Container Registry</li> </ul> <p>Each registry hosts the same images, tagged with their CalVer versions.</p>"},{"location":"cmangos-classic/versions/#most-recent-version","title":"Most Recent Version","text":"<p>For quick reference, here\u2019s the most recent CMangos image:</p> <ul> <li>Latest Version: <code>2024.02.03-1</code></li> <li>Tag: <code>latest</code> (if you prefer to automatically use the newest version)</li> <li>Published On: February 3, 2024</li> </ul> <p>You can always find the most recent version by checking the registries linked above.</p>"},{"location":"cmangos-classic/versions/#summary","title":"Summary","text":"<ul> <li>CalVer helps you easily identify when an image was created and if it\u2019s been updated.</li> <li>Use CalVer tags in your <code>docker-compose.yml</code> for version control.</li> <li>Images are available on Docker Hub, GitHub Container Registry, and GitLab Registry.</li> <li>For stability, pin to specific versions instead of <code>latest</code> unless you\u2019re okay with automatic updates.</li> </ul>"},{"location":"cmangos-classic/bots/ahbot/","title":"AH Bots","text":""},{"location":"cmangos-classic/bots/playerbots/","title":"Playerbots","text":""},{"location":"cmangos-classic/build/building/","title":"Builder Image","text":"<p>The Builder Image is the core component responsible for compiling the CMangos server. It handles the entire build process, from source code to final binary artifacts, ensuring consistency and reliability across different environments.</p>"},{"location":"cmangos-classic/build/building/#what-is-the-builder-image","title":"What is the Builder Image?","text":"<p>The Builder Image:</p> <ul> <li>Runs the Build Process: Executes all steps required to compile CMangos.</li> <li>Includes a Specific Source Version: The source code is pre-baked into the image, ensuring version consistency.</li> <li>Relies on Build Deps: Uses fixed dependencies from the Build Deps image to maintain a stable build environment.</li> <li>Supports Customization: You can set environment variables or pass additional arguments when running the image with <code>docker run</code> to adjust the build process as needed.</li> </ul>"},{"location":"cmangos-classic/build/building/#running-the-builder-image","title":"Running the Builder Image","text":"<p>To build CMangos using the Builder Image, you can run:</p> <pre><code>docker run -e BUILD_OPTION=optimized mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <ul> <li><code>-e BUILD_OPTION=optimized</code> sets an environment variable that customizes the build.</li> <li><code>mockorg/cmangos-builder:2024.02.03-1</code> refers to the specific version of the Builder Image.</li> </ul> <p>After the build completes, the compiled artifacts are placed in an output directory inside the container. You can extract these artifacts by mounting a volume:</p> <pre><code>docker run -v $(pwd)/output:/output mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <p>This command saves the build results to your local <code>output</code> folder.</p>"},{"location":"cmangos-classic/build/building/#hermetic-builds-explained","title":"Hermetic Builds Explained","text":"<p>The Builder Image is designed to produce hermetic builds. But what does \"hermetic\" mean in this context?</p> <p>In simple terms:</p> <p>A hermetic build means that the build process is completely self-contained. It doesn\u2019t rely on anything outside of the Builder Image. This ensures that:</p> <ul> <li>Same Input = Same Output: No matter when or where you run the build, if the source code and settings are the same, the resulting binaries will be identical.</li> <li>No External Influence: The build isn\u2019t affected by your computer\u2019s settings, installed software, or even the current date and time.</li> <li>Predictable Results: Every build is like following a precise recipe\u2014no surprises.</li> </ul> <p>This is achieved by:</p> <ul> <li>Pre-baking the source code into the image.</li> <li>Using fixed dependencies from the Build Deps layer.</li> <li>Controlling the build environment strictly within Docker.</li> </ul>"},{"location":"cmangos-classic/build/building/#why-hermetic-builds-matter","title":"Why Hermetic Builds Matter","text":"<ul> <li>Consistency: Developers and users get the same results every time.</li> <li>Reliability: Easier to debug because there are no hidden variables affecting the build.</li> <li>Security: Reduces risks from external changes, like updates to system libraries or tools.</li> </ul>"},{"location":"cmangos-classic/build/building/#summary","title":"Summary","text":"<ul> <li>The Builder Image handles the full build process for CMangos.</li> <li>It uses pre-baked source code and fixed dependencies from the Build Deps image.</li> <li>You can customize builds with environment variables or arguments via <code>docker run</code>.</li> <li>Hermetic builds ensure that every build is consistent, reproducible, and reliable, no matter where or when it\u2019s run.</li> </ul>"},{"location":"cmangos-classic/build/deps/","title":"Build Deps","text":"<p>The CMangos Docker image architecture follows a modular approach, breaking down the build process into distinct layers for consistency, reproducibility, and maintainability. A critical part of this architecture is the Build Deps layer, which manages the foundational build dependencies required to compile the CMangos server.</p>"},{"location":"cmangos-classic/build/deps/#what-are-build-deps","title":"What are Build Deps?","text":"<p>Build Deps (short for Build Dependencies) refer to the essential system libraries, development tools, and other dependencies needed to build the CMangos project. These include:</p> <ul> <li>Standard Libraries (e.g., <code>libc</code>, <code>libssl</code>)</li> <li>Development Tools (e.g., <code>gcc</code>, <code>make</code>, <code>cmake</code>)</li> <li>Debian Packages required for compiling the source code</li> <li>Other system-level dependencies essential for the build process</li> </ul> <p>These dependencies are only used during the build phase and are not included in the final runtime image, keeping the production environment clean and lightweight.</p>"},{"location":"cmangos-classic/build/deps/#deterministic-builds-with-bazel-and-rules-oci","title":"Deterministic Builds with Bazel and Rules OCI","text":"<p>To ensure that builds are deterministic\u2014meaning the same source code always produces the same output\u2014we use Bazel along with Rules OCI. This combination offers several advantages:</p> <ul> <li>Reproducibility: Regardless of when or where the build occurs, the output will be identical if the source code version remains the same.</li> <li>Version Control: Build dependencies are pinned to specific versions, eliminating inconsistencies from upstream package changes.</li> <li>Efficiency: Bazel\u2019s caching and precise dependency management speed up rebuilds, especially for minor changes.</li> </ul> <p>By leveraging Bazel and Rules OCI, we eliminate variables that could affect build outcomes, ensuring reliable results across development, testing, and production environments.</p>"},{"location":"cmangos-classic/build/deps/#the-builder-image","title":"The Builder Image","text":"<p>The Builder image builds on top of the Build Deps layer. It contains everything required to compile the CMangos server, including:</p> <ul> <li>Pre-installed Build Deps: All necessary libraries and tools for building the source code.</li> <li>Build Scripts and Steps: Automated processes baked into the image to handle compilation.</li> <li>Environment Variables: Configurations required during the build process.</li> <li>Upstream Source Code: Integrated directly from official repositories for clean, version-controlled builds.</li> </ul> <p>The Builder image is solely responsible for the build process. It does not include runtime components, keeping it focused and optimized for its purpose.</p>"},{"location":"cmangos-classic/build/deps/#how-it-all-fits-together","title":"How It All Fits Together","text":"<ol> <li>Build Deps Layer: Provides the foundational dependencies required to build CMangos.</li> <li>Builder Image: Utilizes the Build Deps layer to compile the server code and manage build configurations.</li> <li>Final Runtime Image: Contains only the compiled binaries and runtime dependencies, optimized for performance and minimal size.</li> </ol> <p>This layered architecture allows for greater flexibility, easier updates, and improved security by separating build tools from the final production environment.</p>"},{"location":"cmangos-classic/build/deps/#summary","title":"Summary","text":"<ul> <li>Build Deps manage the critical dependencies required for building CMangos.</li> <li>Dependencies are installed using Bazel and Rules OCI for deterministic, reproducible builds.</li> <li>The Builder Image leverages Build Deps to execute build steps, manage environment variables, and integrate upstream source code.</li> <li>This modular design ensures clean, consistent builds and optimized runtime environments.</li> </ul>"},{"location":"cmangos-classic/build/overview/","title":"High-Level Overview of the Image Build Pattern","text":"<p>The CMangos server is packaged using a carefully designed build pattern that ensures consistency, reliability, and ease of deployment. This pattern breaks the build process into distinct stages, with each stage focusing on a specific part of the process. By separating the build into layers, we can create clean, efficient, and predictable server images that are easy to manage and update.</p> <p>Think of this process like baking a cake:</p> <ul> <li>You gather your ingredients (dependencies).</li> <li>Mix and bake the cake (build the server).</li> <li>Remove the baking tools (runtime environment).</li> <li>Add the final decorations and packaging (final image ready to serve).</li> </ul> <p>Here\u2019s how this pattern works for CMangos:</p> <pre><code>flowchart TD\n    A[Build Deps Image] --&gt; B[Builder Image]\n    B --&gt;|Build Artifacts| D[Final Image]\n    C[Runtime Image] --&gt;|Runtime Dependencies| D\n\n    D --&gt; E[Deployment]\n\n    classDef deps stroke-width:2px;\n    classDef builder stroke-width:2px;\n    classDef runtime stroke-width:2px;\n    classDef final stroke-width:2px;\n\n    class A deps;\n    class B builder;\n    class C runtime;\n    class D final;\n</code></pre>"},{"location":"cmangos-classic/build/overview/#the-four-layers-of-the-build-pattern","title":"The Four Layers of the Build Pattern","text":"<ol> <li> <p>Build Deps (Build Dependencies) Image    Think of this as your pantry of ingredients.    This image contains all the tools, libraries, and system packages needed to build the CMangos server. It includes things like compilers, standard libraries, and other software required to turn the source code into a working program.</p> </li> <li> <p>Purpose: Provides the foundation for the build process.</p> </li> <li> <p>Key Point: It\u2019s not part of the final server. It\u2019s only used to help \"mix the ingredients.\"</p> </li> <li> <p>Builder Image    This is like the kitchen where you prepare the cake.    The Builder Image takes the source code and, using the tools from the Build Deps image, compiles it into working server binaries (the actual program files that run the game server).</p> </li> <li> <p>Purpose: Runs the build process, producing the final server files.</p> </li> <li> <p>Key Point: Includes a specific version of the source code, ensuring the same result every time.</p> </li> <li> <p>Runtime Image    Now the cake is baked, and you\u2019ve cleaned up the kitchen. Only the cake remains.    The Runtime Image is a clean, minimal environment that contains only the files and libraries needed to run the server\u2014nothing extra. All the build tools and unnecessary files are left behind.</p> </li> <li> <p>Purpose: Provides the environment where the CMangos server will run.</p> </li> <li> <p>Key Point: Smaller, faster, and more secure because it doesn\u2019t include unnecessary tools.</p> </li> <li> <p>Final Image    This is the beautifully decorated cake, ready to serve.    The Final Image combines the Runtime Image with the built server files from the Builder Image and adds any necessary configuration files. This is the image you\u2019ll actually deploy to run your CMangos server.</p> </li> <li> <p>Purpose: The complete, deployable server image.</p> </li> <li>Key Point: Contains everything needed to run CMangos in production.</li> </ol>"},{"location":"cmangos-classic/build/overview/#why-this-pattern-matters","title":"Why This Pattern Matters","text":"<ul> <li>Consistency: Every time you build the server, you get the same result\u2014no surprises.</li> <li>Security: By removing unnecessary tools and files, the final image is more secure.</li> <li>Efficiency: Smaller images mean faster deployment and less resource usage.</li> <li>Reproducibility: Builds are deterministic, meaning the same source code always produces the same output.</li> </ul>"},{"location":"cmangos-classic/build/runtime/","title":"Runtime Image","text":"<p>The Runtime Image is the final, deployable container that runs the CMangos server. It is designed to be lightweight, secure, and optimized for performance, containing only the essential components needed to run the server.</p>"},{"location":"cmangos-classic/build/runtime/#what-is-the-runtime-image","title":"What is the Runtime Image?","text":"<p>The Runtime Image:</p> <ul> <li>Contains Only Runtime Dependencies: Unlike the Build Deps image, which includes tools needed for compiling code, the Runtime Image includes just the libraries and packages required for CMangos to function.</li> <li>Packages Built Binaries: The compiled server binaries from the Builder Image are packaged into the Runtime Image.</li> <li>Optimized for Efficiency: By excluding unnecessary build tools and dependencies, the image is smaller and more secure.</li> </ul>"},{"location":"cmangos-classic/build/runtime/#how-the-runtime-image-is-built","title":"How the Runtime Image is Built","text":"<p>The process to create the Runtime Image involves:</p> <ol> <li>Using the Build Deps Model: Similar to the Build Deps image, the Runtime Image is created with fixed, deterministic dependencies to ensure consistency.</li> <li>Packaging Binaries: The built server binaries are copied from the Builder Image into the Runtime Image.</li> <li>Stripping Down the Environment: Any unnecessary files, build tools, or extra data are excluded to keep the image lean.</li> </ol> <p>This results in a minimal container that contains everything needed to run the CMangos server\u2014nothing more, nothing less.</p>"},{"location":"cmangos-classic/build/runtime/#benefits-of-the-runtime-image","title":"Benefits of the Runtime Image","text":"<ul> <li>Smaller Size: Reduces resource usage, making it faster to deploy and more efficient to run.</li> <li>Improved Security: Fewer components mean fewer potential vulnerabilities.</li> <li>Consistency: Built using deterministic methods, ensuring the same runtime environment across all deployments.</li> </ul>"},{"location":"cmangos-classic/build/runtime/#running-the-runtime-image","title":"Running the Runtime Image","text":"<p>Once the Runtime Image is built, you can run it like any standard Docker container:</p> <pre><code>docker run -p 8085:8085 -p 3724:3724 mockorg/cmangos-runtime:2024.02.03-1\n</code></pre> <ul> <li>Ports 8085 and 3724 are exposed for the game server and login server.</li> <li><code>mockorg/cmangos-runtime:2024.02.03-1</code> refers to the specific version of the Runtime Image.</li> </ul> <p>For persistent data (like database storage or logs), you can mount volumes:</p> <pre><code>docker run -v $(pwd)/data:/data mockorg/cmangos-runtime:2024.02.03-1\n</code></pre>"},{"location":"cmangos-classic/build/runtime/#summary","title":"Summary","text":"<ul> <li>The Runtime Image is the final container that runs CMangos, containing only the dependencies needed for runtime.</li> <li>It is built using deterministic methods, similar to the Build Deps image, ensuring consistent, reliable performance.</li> <li>The image packages the built binaries from the Builder Image, creating a clean, minimal environment optimized for deployment.</li> <li>This approach enhances security, reduces resource usage, and simplifies server management.</li> </ul>"},{"location":"cmangos-classic/config/accounts/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"cmangos-classic/config/commands/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"cmangos-classic/config/mangosd/","title":"Mangosd","text":""},{"location":"cmangos-classic/config/mariadb/","title":"MariaDB","text":""},{"location":"cmangos-classic/config/realmd/","title":"RealmD","text":""},{"location":"cmangos-tbc/client-data/","title":"Client Data","text":""},{"location":"cmangos-tbc/clients/","title":"Supported Clients","text":"<p>Supported Clients</p>"},{"location":"cmangos-tbc/installation/","title":"Installing cMaNGOS Classic","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"cmangos-tbc/installation/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"cmangos-tbc/installation/#sample-title","title":"Sample Title","text":"<p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Ctrl+Alt+Del</p>"},{"location":"cmangos-tbc/installation/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"cmangos-tbc/overview/","title":"Getting Started with cMaNGOS TBC","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"cmangos-tbc/overview/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"cmangos-tbc/overview/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"cmangos-tbc/versions/","title":"Versions","text":"<p>Versions</p>"},{"location":"cmangos-tbc/bots/ahbot/","title":"AH Bots","text":""},{"location":"cmangos-tbc/bots/playerbots/","title":"Playerbots","text":""},{"location":"cmangos-tbc/build/building/","title":"Builder Image","text":"<p>The Builder Image is the core component responsible for compiling the CMangos server. It handles the entire build process, from source code to final binary artifacts, ensuring consistency and reliability across different environments.</p>"},{"location":"cmangos-tbc/build/building/#what-is-the-builder-image","title":"What is the Builder Image?","text":"<p>The Builder Image:</p> <ul> <li>Runs the Build Process: Executes all steps required to compile CMangos.</li> <li>Includes a Specific Source Version: The source code is pre-baked into the image, ensuring version consistency.</li> <li>Relies on Build Deps: Uses fixed dependencies from the Build Deps image to maintain a stable build environment.</li> <li>Supports Customization: You can set environment variables or pass additional arguments when running the image with <code>docker run</code> to adjust the build process as needed.</li> </ul>"},{"location":"cmangos-tbc/build/building/#running-the-builder-image","title":"Running the Builder Image","text":"<p>To build CMangos using the Builder Image, you can run:</p> <pre><code>docker run -e BUILD_OPTION=optimized mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <ul> <li><code>-e BUILD_OPTION=optimized</code> sets an environment variable that customizes the build.</li> <li><code>mockorg/cmangos-builder:2024.02.03-1</code> refers to the specific version of the Builder Image.</li> </ul> <p>After the build completes, the compiled artifacts are placed in an output directory inside the container. You can extract these artifacts by mounting a volume:</p> <pre><code>docker run -v $(pwd)/output:/output mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <p>This command saves the build results to your local <code>output</code> folder.</p>"},{"location":"cmangos-tbc/build/building/#hermetic-builds-explained","title":"Hermetic Builds Explained","text":"<p>The Builder Image is designed to produce hermetic builds. But what does \"hermetic\" mean in this context?</p> <p>In simple terms:</p> <p>A hermetic build means that the build process is completely self-contained. It doesn\u2019t rely on anything outside of the Builder Image. This ensures that:</p> <ul> <li>Same Input = Same Output: No matter when or where you run the build, if the source code and settings are the same, the resulting binaries will be identical.</li> <li>No External Influence: The build isn\u2019t affected by your computer\u2019s settings, installed software, or even the current date and time.</li> <li>Predictable Results: Every build is like following a precise recipe\u2014no surprises.</li> </ul> <p>This is achieved by:</p> <ul> <li>Pre-baking the source code into the image.</li> <li>Using fixed dependencies from the Build Deps layer.</li> <li>Controlling the build environment strictly within Docker.</li> </ul>"},{"location":"cmangos-tbc/build/building/#why-hermetic-builds-matter","title":"Why Hermetic Builds Matter","text":"<ul> <li>Consistency: Developers and users get the same results every time.</li> <li>Reliability: Easier to debug because there are no hidden variables affecting the build.</li> <li>Security: Reduces risks from external changes, like updates to system libraries or tools.</li> </ul>"},{"location":"cmangos-tbc/build/building/#summary","title":"Summary","text":"<ul> <li>The Builder Image handles the full build process for CMangos.</li> <li>It uses pre-baked source code and fixed dependencies from the Build Deps image.</li> <li>You can customize builds with environment variables or arguments via <code>docker run</code>.</li> <li>Hermetic builds ensure that every build is consistent, reproducible, and reliable, no matter where or when it\u2019s run.</li> </ul>"},{"location":"cmangos-tbc/build/deps/","title":"Build Deps","text":"<p>The CMangos Docker image architecture follows a modular approach, breaking down the build process into distinct layers for consistency, reproducibility, and maintainability. A critical part of this architecture is the Build Deps layer, which manages the foundational build dependencies required to compile the CMangos server.</p>"},{"location":"cmangos-tbc/build/deps/#what-are-build-deps","title":"What are Build Deps?","text":"<p>Build Deps (short for Build Dependencies) refer to the essential system libraries, development tools, and other dependencies needed to build the CMangos project. These include:</p> <ul> <li>Standard Libraries (e.g., <code>libc</code>, <code>libssl</code>)</li> <li>Development Tools (e.g., <code>gcc</code>, <code>make</code>, <code>cmake</code>)</li> <li>Debian Packages required for compiling the source code</li> <li>Other system-level dependencies essential for the build process</li> </ul> <p>These dependencies are only used during the build phase and are not included in the final runtime image, keeping the production environment clean and lightweight.</p>"},{"location":"cmangos-tbc/build/deps/#deterministic-builds-with-bazel-and-rules-oci","title":"Deterministic Builds with Bazel and Rules OCI","text":"<p>To ensure that builds are deterministic\u2014meaning the same source code always produces the same output\u2014we use Bazel along with Rules OCI. This combination offers several advantages:</p> <ul> <li>Reproducibility: Regardless of when or where the build occurs, the output will be identical if the source code version remains the same.</li> <li>Version Control: Build dependencies are pinned to specific versions, eliminating inconsistencies from upstream package changes.</li> <li>Efficiency: Bazel\u2019s caching and precise dependency management speed up rebuilds, especially for minor changes.</li> </ul> <p>By leveraging Bazel and Rules OCI, we eliminate variables that could affect build outcomes, ensuring reliable results across development, testing, and production environments.</p>"},{"location":"cmangos-tbc/build/deps/#the-builder-image","title":"The Builder Image","text":"<p>The Builder image builds on top of the Build Deps layer. It contains everything required to compile the CMangos server, including:</p> <ul> <li>Pre-installed Build Deps: All necessary libraries and tools for building the source code.</li> <li>Build Scripts and Steps: Automated processes baked into the image to handle compilation.</li> <li>Environment Variables: Configurations required during the build process.</li> <li>Upstream Source Code: Integrated directly from official repositories for clean, version-controlled builds.</li> </ul> <p>The Builder image is solely responsible for the build process. It does not include runtime components, keeping it focused and optimized for its purpose.</p>"},{"location":"cmangos-tbc/build/deps/#how-it-all-fits-together","title":"How It All Fits Together","text":"<ol> <li>Build Deps Layer: Provides the foundational dependencies required to build CMangos.</li> <li>Builder Image: Utilizes the Build Deps layer to compile the server code and manage build configurations.</li> <li>Final Runtime Image: Contains only the compiled binaries and runtime dependencies, optimized for performance and minimal size.</li> </ol> <p>This layered architecture allows for greater flexibility, easier updates, and improved security by separating build tools from the final production environment.</p>"},{"location":"cmangos-tbc/build/deps/#summary","title":"Summary","text":"<ul> <li>Build Deps manage the critical dependencies required for building CMangos.</li> <li>Dependencies are installed using Bazel and Rules OCI for deterministic, reproducible builds.</li> <li>The Builder Image leverages Build Deps to execute build steps, manage environment variables, and integrate upstream source code.</li> <li>This modular design ensures clean, consistent builds and optimized runtime environments.</li> </ul>"},{"location":"cmangos-tbc/build/overview/","title":"High-Level Overview of the Image Build Pattern","text":"<p>The CMangos server is packaged using a carefully designed build pattern that ensures consistency, reliability, and ease of deployment. This pattern breaks the build process into distinct stages, with each stage focusing on a specific part of the process. By separating the build into layers, we can create clean, efficient, and predictable server images that are easy to manage and update.</p> <p>Think of this process like baking a cake:</p> <ul> <li>You gather your ingredients (dependencies).</li> <li>Mix and bake the cake (build the server).</li> <li>Remove the baking tools (runtime environment).</li> <li>Add the final decorations and packaging (final image ready to serve).</li> </ul> <p>Here\u2019s how this pattern works for CMangos:</p> <pre><code>flowchart TD\n    A[Build Deps Image] --&gt; B[Builder Image]\n    B --&gt;|Build Artifacts| D[Final Image]\n    C[Runtime Image] --&gt;|Runtime Dependencies| D\n\n    D --&gt; E[Deployment]\n\n    classDef deps stroke-width:2px;\n    classDef builder stroke-width:2px;\n    classDef runtime stroke-width:2px;\n    classDef final stroke-width:2px;\n\n    class A deps;\n    class B builder;\n    class C runtime;\n    class D final;\n</code></pre>"},{"location":"cmangos-tbc/build/overview/#the-four-layers-of-the-build-pattern","title":"The Four Layers of the Build Pattern","text":"<ol> <li> <p>Build Deps (Build Dependencies) Image    Think of this as your pantry of ingredients.    This image contains all the tools, libraries, and system packages needed to build the CMangos server. It includes things like compilers, standard libraries, and other software required to turn the source code into a working program.</p> </li> <li> <p>Purpose: Provides the foundation for the build process.</p> </li> <li> <p>Key Point: It\u2019s not part of the final server. It\u2019s only used to help \"mix the ingredients.\"</p> </li> <li> <p>Builder Image    This is like the kitchen where you prepare the cake.    The Builder Image takes the source code and, using the tools from the Build Deps image, compiles it into working server binaries (the actual program files that run the game server).</p> </li> <li> <p>Purpose: Runs the build process, producing the final server files.</p> </li> <li> <p>Key Point: Includes a specific version of the source code, ensuring the same result every time.</p> </li> <li> <p>Runtime Image    Now the cake is baked, and you\u2019ve cleaned up the kitchen. Only the cake remains.    The Runtime Image is a clean, minimal environment that contains only the files and libraries needed to run the server\u2014nothing extra. All the build tools and unnecessary files are left behind.</p> </li> <li> <p>Purpose: Provides the environment where the CMangos server will run.</p> </li> <li> <p>Key Point: Smaller, faster, and more secure because it doesn\u2019t include unnecessary tools.</p> </li> <li> <p>Final Image    This is the beautifully decorated cake, ready to serve.    The Final Image combines the Runtime Image with the built server files from the Builder Image and adds any necessary configuration files. This is the image you\u2019ll actually deploy to run your CMangos server.</p> </li> <li> <p>Purpose: The complete, deployable server image.</p> </li> <li>Key Point: Contains everything needed to run CMangos in production.</li> </ol>"},{"location":"cmangos-tbc/build/overview/#why-this-pattern-matters","title":"Why This Pattern Matters","text":"<ul> <li>Consistency: Every time you build the server, you get the same result\u2014no surprises.</li> <li>Security: By removing unnecessary tools and files, the final image is more secure.</li> <li>Efficiency: Smaller images mean faster deployment and less resource usage.</li> <li>Reproducibility: Builds are deterministic, meaning the same source code always produces the same output.</li> </ul>"},{"location":"cmangos-tbc/build/runtime/","title":"Runtime Image","text":"<p>The Runtime Image is the final, deployable container that runs the CMangos server. It is designed to be lightweight, secure, and optimized for performance, containing only the essential components needed to run the server.</p>"},{"location":"cmangos-tbc/build/runtime/#what-is-the-runtime-image","title":"What is the Runtime Image?","text":"<p>The Runtime Image:</p> <ul> <li>Contains Only Runtime Dependencies: Unlike the Build Deps image, which includes tools needed for compiling code, the Runtime Image includes just the libraries and packages required for CMangos to function.</li> <li>Packages Built Binaries: The compiled server binaries from the Builder Image are packaged into the Runtime Image.</li> <li>Optimized for Efficiency: By excluding unnecessary build tools and dependencies, the image is smaller and more secure.</li> </ul>"},{"location":"cmangos-tbc/build/runtime/#how-the-runtime-image-is-built","title":"How the Runtime Image is Built","text":"<p>The process to create the Runtime Image involves:</p> <ol> <li>Using the Build Deps Model: Similar to the Build Deps image, the Runtime Image is created with fixed, deterministic dependencies to ensure consistency.</li> <li>Packaging Binaries: The built server binaries are copied from the Builder Image into the Runtime Image.</li> <li>Stripping Down the Environment: Any unnecessary files, build tools, or extra data are excluded to keep the image lean.</li> </ol> <p>This results in a minimal container that contains everything needed to run the CMangos server\u2014nothing more, nothing less.</p>"},{"location":"cmangos-tbc/build/runtime/#benefits-of-the-runtime-image","title":"Benefits of the Runtime Image","text":"<ul> <li>Smaller Size: Reduces resource usage, making it faster to deploy and more efficient to run.</li> <li>Improved Security: Fewer components mean fewer potential vulnerabilities.</li> <li>Consistency: Built using deterministic methods, ensuring the same runtime environment across all deployments.</li> </ul>"},{"location":"cmangos-tbc/build/runtime/#running-the-runtime-image","title":"Running the Runtime Image","text":"<p>Once the Runtime Image is built, you can run it like any standard Docker container:</p> <pre><code>docker run -p 8085:8085 -p 3724:3724 mockorg/cmangos-runtime:2024.02.03-1\n</code></pre> <ul> <li>Ports 8085 and 3724 are exposed for the game server and login server.</li> <li><code>mockorg/cmangos-runtime:2024.02.03-1</code> refers to the specific version of the Runtime Image.</li> </ul> <p>For persistent data (like database storage or logs), you can mount volumes:</p> <pre><code>docker run -v $(pwd)/data:/data mockorg/cmangos-runtime:2024.02.03-1\n</code></pre>"},{"location":"cmangos-tbc/build/runtime/#summary","title":"Summary","text":"<ul> <li>The Runtime Image is the final container that runs CMangos, containing only the dependencies needed for runtime.</li> <li>It is built using deterministic methods, similar to the Build Deps image, ensuring consistent, reliable performance.</li> <li>The image packages the built binaries from the Builder Image, creating a clean, minimal environment optimized for deployment.</li> <li>This approach enhances security, reduces resource usage, and simplifies server management.</li> </ul>"},{"location":"cmangos-tbc/config/accounts/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"cmangos-tbc/config/commands/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"cmangos-tbc/config/mangosd/","title":"Mangosd","text":""},{"location":"cmangos-tbc/config/mariadb/","title":"MariaDB","text":""},{"location":"cmangos-tbc/config/realmd/","title":"RealmD","text":""},{"location":"cmangos-wotlk/client-data/","title":"Client Data","text":""},{"location":"cmangos-wotlk/clients/","title":"Supported Clients","text":"<p>Supported Clients</p>"},{"location":"cmangos-wotlk/installation/","title":"Installing cMaNGOS Classic","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"cmangos-wotlk/installation/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"cmangos-wotlk/installation/#sample-title","title":"Sample Title","text":"<p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Ctrl+Alt+Del</p>"},{"location":"cmangos-wotlk/installation/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"cmangos-wotlk/overview/","title":"Getting Started with cMaNGOS WOTLK","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"cmangos-wotlk/overview/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"cmangos-wotlk/overview/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"cmangos-wotlk/versions/","title":"Versions","text":"<p>Versions</p>"},{"location":"cmangos-wotlk/bots/ahbot/","title":"AH Bots","text":""},{"location":"cmangos-wotlk/bots/playerbots/","title":"Playerbots","text":""},{"location":"cmangos-wotlk/build/building/","title":"Builder Image","text":"<p>The Builder Image is the core component responsible for compiling the CMangos server. It handles the entire build process, from source code to final binary artifacts, ensuring consistency and reliability across different environments.</p>"},{"location":"cmangos-wotlk/build/building/#what-is-the-builder-image","title":"What is the Builder Image?","text":"<p>The Builder Image:</p> <ul> <li>Runs the Build Process: Executes all steps required to compile CMangos.</li> <li>Includes a Specific Source Version: The source code is pre-baked into the image, ensuring version consistency.</li> <li>Relies on Build Deps: Uses fixed dependencies from the Build Deps image to maintain a stable build environment.</li> <li>Supports Customization: You can set environment variables or pass additional arguments when running the image with <code>docker run</code> to adjust the build process as needed.</li> </ul>"},{"location":"cmangos-wotlk/build/building/#running-the-builder-image","title":"Running the Builder Image","text":"<p>To build CMangos using the Builder Image, you can run:</p> <pre><code>docker run -e BUILD_OPTION=optimized mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <ul> <li><code>-e BUILD_OPTION=optimized</code> sets an environment variable that customizes the build.</li> <li><code>mockorg/cmangos-builder:2024.02.03-1</code> refers to the specific version of the Builder Image.</li> </ul> <p>After the build completes, the compiled artifacts are placed in an output directory inside the container. You can extract these artifacts by mounting a volume:</p> <pre><code>docker run -v $(pwd)/output:/output mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <p>This command saves the build results to your local <code>output</code> folder.</p>"},{"location":"cmangos-wotlk/build/building/#hermetic-builds-explained","title":"Hermetic Builds Explained","text":"<p>The Builder Image is designed to produce hermetic builds. But what does \"hermetic\" mean in this context?</p> <p>In simple terms:</p> <p>A hermetic build means that the build process is completely self-contained. It doesn\u2019t rely on anything outside of the Builder Image. This ensures that:</p> <ul> <li>Same Input = Same Output: No matter when or where you run the build, if the source code and settings are the same, the resulting binaries will be identical.</li> <li>No External Influence: The build isn\u2019t affected by your computer\u2019s settings, installed software, or even the current date and time.</li> <li>Predictable Results: Every build is like following a precise recipe\u2014no surprises.</li> </ul> <p>This is achieved by:</p> <ul> <li>Pre-baking the source code into the image.</li> <li>Using fixed dependencies from the Build Deps layer.</li> <li>Controlling the build environment strictly within Docker.</li> </ul>"},{"location":"cmangos-wotlk/build/building/#why-hermetic-builds-matter","title":"Why Hermetic Builds Matter","text":"<ul> <li>Consistency: Developers and users get the same results every time.</li> <li>Reliability: Easier to debug because there are no hidden variables affecting the build.</li> <li>Security: Reduces risks from external changes, like updates to system libraries or tools.</li> </ul>"},{"location":"cmangos-wotlk/build/building/#summary","title":"Summary","text":"<ul> <li>The Builder Image handles the full build process for CMangos.</li> <li>It uses pre-baked source code and fixed dependencies from the Build Deps image.</li> <li>You can customize builds with environment variables or arguments via <code>docker run</code>.</li> <li>Hermetic builds ensure that every build is consistent, reproducible, and reliable, no matter where or when it\u2019s run.</li> </ul>"},{"location":"cmangos-wotlk/build/deps/","title":"Build Deps","text":"<p>The CMangos Docker image architecture follows a modular approach, breaking down the build process into distinct layers for consistency, reproducibility, and maintainability. A critical part of this architecture is the Build Deps layer, which manages the foundational build dependencies required to compile the CMangos server.</p>"},{"location":"cmangos-wotlk/build/deps/#what-are-build-deps","title":"What are Build Deps?","text":"<p>Build Deps (short for Build Dependencies) refer to the essential system libraries, development tools, and other dependencies needed to build the CMangos project. These include:</p> <ul> <li>Standard Libraries (e.g., <code>libc</code>, <code>libssl</code>)</li> <li>Development Tools (e.g., <code>gcc</code>, <code>make</code>, <code>cmake</code>)</li> <li>Debian Packages required for compiling the source code</li> <li>Other system-level dependencies essential for the build process</li> </ul> <p>These dependencies are only used during the build phase and are not included in the final runtime image, keeping the production environment clean and lightweight.</p>"},{"location":"cmangos-wotlk/build/deps/#deterministic-builds-with-bazel-and-rules-oci","title":"Deterministic Builds with Bazel and Rules OCI","text":"<p>To ensure that builds are deterministic\u2014meaning the same source code always produces the same output\u2014we use Bazel along with Rules OCI. This combination offers several advantages:</p> <ul> <li>Reproducibility: Regardless of when or where the build occurs, the output will be identical if the source code version remains the same.</li> <li>Version Control: Build dependencies are pinned to specific versions, eliminating inconsistencies from upstream package changes.</li> <li>Efficiency: Bazel\u2019s caching and precise dependency management speed up rebuilds, especially for minor changes.</li> </ul> <p>By leveraging Bazel and Rules OCI, we eliminate variables that could affect build outcomes, ensuring reliable results across development, testing, and production environments.</p>"},{"location":"cmangos-wotlk/build/deps/#the-builder-image","title":"The Builder Image","text":"<p>The Builder image builds on top of the Build Deps layer. It contains everything required to compile the CMangos server, including:</p> <ul> <li>Pre-installed Build Deps: All necessary libraries and tools for building the source code.</li> <li>Build Scripts and Steps: Automated processes baked into the image to handle compilation.</li> <li>Environment Variables: Configurations required during the build process.</li> <li>Upstream Source Code: Integrated directly from official repositories for clean, version-controlled builds.</li> </ul> <p>The Builder image is solely responsible for the build process. It does not include runtime components, keeping it focused and optimized for its purpose.</p>"},{"location":"cmangos-wotlk/build/deps/#how-it-all-fits-together","title":"How It All Fits Together","text":"<ol> <li>Build Deps Layer: Provides the foundational dependencies required to build CMangos.</li> <li>Builder Image: Utilizes the Build Deps layer to compile the server code and manage build configurations.</li> <li>Final Runtime Image: Contains only the compiled binaries and runtime dependencies, optimized for performance and minimal size.</li> </ol> <p>This layered architecture allows for greater flexibility, easier updates, and improved security by separating build tools from the final production environment.</p>"},{"location":"cmangos-wotlk/build/deps/#summary","title":"Summary","text":"<ul> <li>Build Deps manage the critical dependencies required for building CMangos.</li> <li>Dependencies are installed using Bazel and Rules OCI for deterministic, reproducible builds.</li> <li>The Builder Image leverages Build Deps to execute build steps, manage environment variables, and integrate upstream source code.</li> <li>This modular design ensures clean, consistent builds and optimized runtime environments.</li> </ul>"},{"location":"cmangos-wotlk/build/overview/","title":"High-Level Overview of the Image Build Pattern","text":"<p>The CMangos server is packaged using a carefully designed build pattern that ensures consistency, reliability, and ease of deployment. This pattern breaks the build process into distinct stages, with each stage focusing on a specific part of the process. By separating the build into layers, we can create clean, efficient, and predictable server images that are easy to manage and update.</p> <p>Think of this process like baking a cake:</p> <ul> <li>You gather your ingredients (dependencies).</li> <li>Mix and bake the cake (build the server).</li> <li>Remove the baking tools (runtime environment).</li> <li>Add the final decorations and packaging (final image ready to serve).</li> </ul> <p>Here\u2019s how this pattern works for CMangos:</p> <pre><code>flowchart TD\n    A[Build Deps Image] --&gt; B[Builder Image]\n    B --&gt;|Build Artifacts| D[Final Image]\n    C[Runtime Image] --&gt;|Runtime Dependencies| D\n\n    D --&gt; E[Deployment]\n\n    classDef deps stroke-width:2px;\n    classDef builder stroke-width:2px;\n    classDef runtime stroke-width:2px;\n    classDef final stroke-width:2px;\n\n    class A deps;\n    class B builder;\n    class C runtime;\n    class D final;\n</code></pre>"},{"location":"cmangos-wotlk/build/overview/#the-four-layers-of-the-build-pattern","title":"The Four Layers of the Build Pattern","text":"<ol> <li> <p>Build Deps (Build Dependencies) Image    Think of this as your pantry of ingredients.    This image contains all the tools, libraries, and system packages needed to build the CMangos server. It includes things like compilers, standard libraries, and other software required to turn the source code into a working program.</p> </li> <li> <p>Purpose: Provides the foundation for the build process.</p> </li> <li> <p>Key Point: It\u2019s not part of the final server. It\u2019s only used to help \"mix the ingredients.\"</p> </li> <li> <p>Builder Image    This is like the kitchen where you prepare the cake.    The Builder Image takes the source code and, using the tools from the Build Deps image, compiles it into working server binaries (the actual program files that run the game server).</p> </li> <li> <p>Purpose: Runs the build process, producing the final server files.</p> </li> <li> <p>Key Point: Includes a specific version of the source code, ensuring the same result every time.</p> </li> <li> <p>Runtime Image    Now the cake is baked, and you\u2019ve cleaned up the kitchen. Only the cake remains.    The Runtime Image is a clean, minimal environment that contains only the files and libraries needed to run the server\u2014nothing extra. All the build tools and unnecessary files are left behind.</p> </li> <li> <p>Purpose: Provides the environment where the CMangos server will run.</p> </li> <li> <p>Key Point: Smaller, faster, and more secure because it doesn\u2019t include unnecessary tools.</p> </li> <li> <p>Final Image    This is the beautifully decorated cake, ready to serve.    The Final Image combines the Runtime Image with the built server files from the Builder Image and adds any necessary configuration files. This is the image you\u2019ll actually deploy to run your CMangos server.</p> </li> <li> <p>Purpose: The complete, deployable server image.</p> </li> <li>Key Point: Contains everything needed to run CMangos in production.</li> </ol>"},{"location":"cmangos-wotlk/build/overview/#why-this-pattern-matters","title":"Why This Pattern Matters","text":"<ul> <li>Consistency: Every time you build the server, you get the same result\u2014no surprises.</li> <li>Security: By removing unnecessary tools and files, the final image is more secure.</li> <li>Efficiency: Smaller images mean faster deployment and less resource usage.</li> <li>Reproducibility: Builds are deterministic, meaning the same source code always produces the same output.</li> </ul>"},{"location":"cmangos-wotlk/build/runtime/","title":"Runtime Image","text":"<p>The Runtime Image is the final, deployable container that runs the CMangos server. It is designed to be lightweight, secure, and optimized for performance, containing only the essential components needed to run the server.</p>"},{"location":"cmangos-wotlk/build/runtime/#what-is-the-runtime-image","title":"What is the Runtime Image?","text":"<p>The Runtime Image:</p> <ul> <li>Contains Only Runtime Dependencies: Unlike the Build Deps image, which includes tools needed for compiling code, the Runtime Image includes just the libraries and packages required for CMangos to function.</li> <li>Packages Built Binaries: The compiled server binaries from the Builder Image are packaged into the Runtime Image.</li> <li>Optimized for Efficiency: By excluding unnecessary build tools and dependencies, the image is smaller and more secure.</li> </ul>"},{"location":"cmangos-wotlk/build/runtime/#how-the-runtime-image-is-built","title":"How the Runtime Image is Built","text":"<p>The process to create the Runtime Image involves:</p> <ol> <li>Using the Build Deps Model: Similar to the Build Deps image, the Runtime Image is created with fixed, deterministic dependencies to ensure consistency.</li> <li>Packaging Binaries: The built server binaries are copied from the Builder Image into the Runtime Image.</li> <li>Stripping Down the Environment: Any unnecessary files, build tools, or extra data are excluded to keep the image lean.</li> </ol> <p>This results in a minimal container that contains everything needed to run the CMangos server\u2014nothing more, nothing less.</p>"},{"location":"cmangos-wotlk/build/runtime/#benefits-of-the-runtime-image","title":"Benefits of the Runtime Image","text":"<ul> <li>Smaller Size: Reduces resource usage, making it faster to deploy and more efficient to run.</li> <li>Improved Security: Fewer components mean fewer potential vulnerabilities.</li> <li>Consistency: Built using deterministic methods, ensuring the same runtime environment across all deployments.</li> </ul>"},{"location":"cmangos-wotlk/build/runtime/#running-the-runtime-image","title":"Running the Runtime Image","text":"<p>Once the Runtime Image is built, you can run it like any standard Docker container:</p> <pre><code>docker run -p 8085:8085 -p 3724:3724 mockorg/cmangos-runtime:2024.02.03-1\n</code></pre> <ul> <li>Ports 8085 and 3724 are exposed for the game server and login server.</li> <li><code>mockorg/cmangos-runtime:2024.02.03-1</code> refers to the specific version of the Runtime Image.</li> </ul> <p>For persistent data (like database storage or logs), you can mount volumes:</p> <pre><code>docker run -v $(pwd)/data:/data mockorg/cmangos-runtime:2024.02.03-1\n</code></pre>"},{"location":"cmangos-wotlk/build/runtime/#summary","title":"Summary","text":"<ul> <li>The Runtime Image is the final container that runs CMangos, containing only the dependencies needed for runtime.</li> <li>It is built using deterministic methods, similar to the Build Deps image, ensuring consistent, reliable performance.</li> <li>The image packages the built binaries from the Builder Image, creating a clean, minimal environment optimized for deployment.</li> <li>This approach enhances security, reduces resource usage, and simplifies server management.</li> </ul>"},{"location":"cmangos-wotlk/config/accounts/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"cmangos-wotlk/config/commands/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"cmangos-wotlk/config/mangosd/","title":"Mangosd","text":""},{"location":"cmangos-wotlk/config/mariadb/","title":"MariaDB","text":""},{"location":"cmangos-wotlk/config/realmd/","title":"RealmD","text":""},{"location":"thoriumlxc/client-data/","title":"Understanding Client Data in VMangos","text":""},{"location":"thoriumlxc/client-data/#concept-of-client-data","title":"Concept of Client Data","text":"<p>Client data refers to the game files extracted from the World of Warcraft client, including essential elements like maps and VMAP data. This data is crucial for the server to accurately replicate the game environment.</p>"},{"location":"thoriumlxc/client-data/#extracting-client-data","title":"Extracting Client Data","text":"<p>To extract client data, you typically run a command in a terminal environment. Here's a simplified example:</p> <pre><code>docker run --rm \\\n  -v /path/to/client:/client \\\n  -v /path/to/output:/output \\\n  vmap-extractor\n</code></pre> <p>In this command: - <code>/path/to/client</code> is the directory containing the game client. - <code>/path/to/output</code> is where the extracted data will be stored.</p>"},{"location":"thoriumlxc/client-data/#client-data-in-docker","title":"Client Data in Docker","text":"<p>In Docker, client data can be stored in named volumes, which simplifies management and transfer. This approach makes it easy to share the extracted data between different systems or Docker containers.</p>"},{"location":"thoriumlxc/compose/","title":"Docker Compose Setup","text":"<p>ThoriumLXC makes downloadable git repositories available that provide the Docker configurations for running the emulation servers. Th</p> <p>It assumes that Docker and Docker Compose are already installed on your system, if you have not installed them yet, please visit the installation guide. All commands shown here should be typed into a Terminal.</p> <p>Tip</p> <p>This page assumes the name of the compose file is <code>compose.yaml</code></p>"},{"location":"thoriumlxc/compose/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have Docker and Docker Compose installed and configured on your machine. Running the command below confirms that Docker is accessible:</p> <pre><code>docker --version\n</code></pre> <p>If this command does not show a valid Docker version, refer to the official documentation on Docker\u2019s website to install and set up Docker correctly. This will look something like the following, likely with a different version &amp; build ID (<code>27.3.1</code>, <code>ce12230</code>):</p> <pre><code>Docker version 27.3.1, build ce12230\n</code></pre> <p>You can also verify Docker Compose by checking for its helpdoc:</p> <pre><code>docker compose --help\n</code></pre> <p>which will look like roughly like the following:</p> <pre><code>Usage:  docker compose [OPTIONS] COMMAND\n\nDefine and run multi-container applications with Docker\n\nOptions:\n    --all-resources              Include all resources, even those not\n                                used by services\n    --ansi string                Control when to print ANSI control\n                                characters (\"never\"|\"always\"|\"auto\")\n                                (default \"auto\")\n    --compatibility              Run compose in backward compatibility mode\n    --dry-run                    Execute command in dry run mode\n    --env-file stringArray       Specify an alternate environment file\n-f, --file stringArray           Compose configuration files\n    --parallel int               Control max parallelism, -1 for\n                                unlimited (default -1)\n    --profile stringArray        Specify a profile to enable\n    --progress string            Set type of progress output (auto,\n                                tty, plain, json, quiet) (default \"auto\")\n    --project-directory string   Specify an alternate working directory\n                                (default: the path of the, first\n                                specified, Compose file)\n-p, --project-name string        Project name\n\nCommands:\n    attach      Attach local standard input, output, and error streams to a service's running container\n    build       Build or rebuild services\n    config      Parse, resolve and render compose file in canonical format\n    cp          Copy files/folders between a service container and the local filesystem\n    create      Creates containers for a service\n    down        Stop and remove containers, networks\n    events      Receive real time events from containers\n    exec        Execute a command in a running container\n    export      Export a service container's filesystem as a tar archive\n    images      List images used by the created containers\n    kill        Force stop service containers\n    logs        View output from containers\n    ls          List running compose projects\n    pause       Pause services\n    port        Print the public port for a port binding\n    ps          List containers\n    pull        Pull service images\n    push        Push service images\n    restart     Restart service containers\n    rm          Removes stopped service containers\n    run         Run a one-off command on a service\n    scale       Scale services\n    start       Start services\n    stats       Display a live stream of container(s) resource usage statistics\n    stop        Stop services\n    top         Display the running processes\n    unpause     Unpause services\n    up          Create and start containers\n    version     Show the Docker Compose version information\n    wait        Block until containers of all (or specified) services stop.\n    watch       Watch build context for service and rebuild/refresh containers when files are updated\n\nRun 'docker compose COMMAND --help' for more information on a command.\n</code></pre> <p>Confirming both means you are ready to proceed.</p>"},{"location":"thoriumlxc/compose/#pulling-docker-images","title":"Pulling Docker Images","text":"<p>When you are in the project folder, you can download the images that the Docker Compose configuration requires by typing:</p> <pre><code>docker compose pull\n</code></pre> <p>This command fetches all the images declared in the <code>compose.yml</code> file and stores them on your machine. If you already have a compatible version of these images, Docker may skip downloading or perform a quick update check. Think of Docker images as the building blocks that your containers will be created from.</p>"},{"location":"thoriumlxc/compose/#starting-the-server","title":"Starting the Server","text":"<p>Once the images are ready, you can start the Mangos server by typing:</p> <pre><code>docker compose up\n</code></pre> <p>This action starts each container specified in the <code>compose.yml</code> file. The Terminal will display output that shows the server initiating. If you want the server to keep running in the background so you can use the same Terminal window for other tasks, you can add the <code>-d</code> flag:</p> <pre><code>docker compose up -d\n</code></pre> <p>By adding <code>-d</code>, you instruct Docker Compose to run in \u201cdetached\u201d mode, meaning the containers keep running until you stop them, even if you close your Terminal window.</p>"},{"location":"thoriumlxc/compose/#stopping-the-server","title":"Stopping the Server","text":"<p>If you need to pause the running server without removing the containers, you can type:</p> <pre><code>docker compose stop\n</code></pre> <p>Stopping works well if you plan to resume operations soon and would like to avoid recreating containers. It halts the running processes but leaves them on your system in a stopped state.</p>"},{"location":"thoriumlxc/compose/#removing-containers","title":"Removing Containers","text":"<p>To remove the containers completely and free up any resources they consume, you can type:</p> <pre><code>docker compose down\n</code></pre> <p>Removing containers can be useful if you want a clean environment each time you start the server. When you run <code>down</code>, Docker Compose not only stops the containers but also deletes them from your system.</p>"},{"location":"thoriumlxc/compose/#full-cleanup","title":"Full Cleanup","text":"<p>If you wish to remove all the containers and the underlying images they depend on, you can type:</p> <pre><code>docker compose down --rmi all\n</code></pre> <p>This command fully cleans everything associated with this project\u2019s Docker environment, including the images. Keep in mind that if you run this command and later choose to start the server again, Docker will need to pull the images once more, which may take some time depending on your internet speed.</p>"},{"location":"thoriumlxc/compose/#viewing-logs","title":"Viewing Logs","text":"<p>While the server is running, you can inspect its logs by typing:</p> <pre><code>docker compose logs\n</code></pre> <p>This command shows the output generated by the containers. If you want to follow the logs in real time and watch new entries as they appear, add the <code>-f</code> flag:</p> <pre><code>docker compose logs -f\n</code></pre> <p>Viewing the logs is a practical way to troubleshoot any issues or just keep track of what the server is doing.</p>"},{"location":"thoriumlxc/getting-started/","title":"Getting Started","text":"<p>ThoriumLXC is an opinionated set of container images designed to run CMangos, VMangos, and similar projects within Docker containers.Container images are like packaged \u201cblueprints\u201d that include everything an application needs to run\u2014its code, system tools, and libraries. Instead of installing software on each machine and worrying about differences in settings, you can think of container images as self-contained boxes that work the same wherever they go.</p> <p>These images are opinionated, with the expectation to be running with Docker Compose.</p> <p>You can learn more about the design of these in Design.</p>"},{"location":"thoriumlxc/getting-started/#prerequisite-installation","title":"Prerequisite Installation","text":"<p>Before diving into any of the individual container images, you'll need to perform the prerequisite installation steps outlined in the Installation Guide. These steps are responsible for installing everything you'd need to be able to run one of the environments.</p>"},{"location":"thoriumlxc/getting-started/#project-configurations","title":"Project Configurations","text":"<p>ThoriumLXC makes downloadable git repositories available that provide the Docker configurations for running the emulation servers. Th</p> <p>It assumes that Docker and Docker Compose are already installed on your system, if you have not installed them yet, please visit the installation guide. All commands shown here should be typed into a Terminal.</p> <p>All of the downloadable git repositories will follow the file structure:</p> <pre><code>.\n\u251c\u2500\u2500 compose.yaml\n\u251c\u2500\u2500 mangosd.conf\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 realmd.conf\n</code></pre> <p>This will look like the following within the file system viewer for your operating system:</p>"},{"location":"thoriumlxc/getting-started/#downloading-the-project","title":"Downloading the Project","text":"<p>Tip</p> <p>This is an overview, if you are looking for a specific guide, navigate to the project page</p> <p>To get the files for this a docker compose setup, you will visit the repository on GitHub. Under the green \u201cCode\u201d button (or in the \u201cReleases\u201d section, if one is provided), you will see an option to download a ZIP archive of the code. Download and save the ZIP archive to a location on your computer, then extract its contents. You will end up with a folder that includes the <code>docker-compose.yml</code> file and other necessary files for the Mangos server.</p> <p>After extracting, open your Terminal or Command Prompt and navigate to the newly created folder. For instance, you could type something like:</p> <pre><code>cd /path/to/unzipped/folder\n</code></pre> <p>Adjust the command above to match the folder location where you extracted the archive. Once you are inside this folder, the Docker Compose commands explained in the rest of this document will apply.</p>"},{"location":"thoriumlxc/getting-started/#container-images","title":"Container Images","text":"<p>Note</p> <p>Each container image has instructions for installing the specific container image.</p> vMaNGOScMaNGOS ClassiccMaNGOS TBCcMaNGOS WOTLKAzerothCore <p> vMaNGOS is an open-source project devoted to accurately recreating an earlier era of a classic fantasy MMO. Building on established frameworks, it offers a stable environment for enthusiasts who want to explore, preserve, or customize the original game content, staying true to the core gameplay and features.</p> <p> cMaNGOS Classic is an open-source project focused on recreating the gameplay and world from a well-known classic fantasy MMO era. It provides a stable, community-driven environment for enthusiasts who want to preserve and explore earlier game mechanics. With its emphasis on authenticity, cMaNGOS-Classic ensures that the original content\u2014quests, zones, and core systems\u2014remain as accurate as possible to their roots.</p> <p> cMaNGOS TBC is an open-source project dedicated to preserving and recreating the second major era of a classic fantasy MMO. Building on the foundation of earlier versions, cMaNGOS TBC incorporates new zones, gameplay improvements, and additional features while maintaining authenticity and stability, allowing enthusiasts to experience the progression of content in its earlier form.</p> <p> cMaNGOS WOTLK is an open-source project focused on recreating the third major era of a classic fantasy MMO. It expands on the previous content with new zones, storyline developments, and updated mechanics, while maintaining accuracy and stability. This allows enthusiasts to explore and experience the progression and features introduced during this iconic period.</p> <p> AzerothCore is an open-source MMO server framework that aims to provide a robust, flexible, and actively maintained environment for creating and running your own game worlds. It supports a variety of features and expansions, offering a strong base for developers and communities to build upon and customize.</p>"},{"location":"thoriumlxc/installation/","title":"Installation Guide","text":"<p>ThoriumLXC is an opinionated set of container images designed to run cMaNGOS, vMaNGOS, and similar projects within Docker containers. Container images are like packaged \u201cblueprints\u201d that include everything an application needs to run\u2014its code, system tools, and libraries.</p> <p>Instead of installing software on each machine and worrying about differences in settings, you can think of container images as self-contained boxes that work the same wherever they go.</p> <p></p> <p>Docker is a popular tool that creates, shares, and runs these containers. It takes a container image, places it in a controlled environment (\u201cthe container\u201d), and ensures it runs the same way on any system.</p> <p>This makes it simpler to ship, and maintain software without worrying about the nitty-gritty details of each machine\u2019s setup.</p>"},{"location":"thoriumlxc/installation/#a-terminal-environment","title":"A Terminal Environment","text":"Windows MacOS Ubuntu (Linux) <p>A terminal environment is a text-based window where you type commands to communicate directly with a computer\u2019s operating system. Think of it as a simple interface\u2014no buttons or icons\u2014just typed instructions and responses. You'll need a terminal to work with Docker Compose, which is a tool for defining and running multi-container applications.</p> <p>For Windows, it is recommended to use Windows Terminal. You can verify the terminal is working by running:</p> <pre><code>echo \"Hello\"\n</code></pre> <p></p> <p>The terminal should respond back with <code>Hello</code>. This will confirm that you have a working Terminal environment.</p> <p>A terminal environment is a text-based window where you type commands to communicate directly with a computer\u2019s operating system. Think of it as a simple interface\u2014no buttons or icons\u2014just typed instructions and responses. You'll need a terminal to work with Docker Compose, which is a tool for defining and running multi-container applications.</p> <p>The default Terminal app is sufficient.</p> <p>You can verify the terminal is working by running:</p> <pre><code>echo \"Hello\"\n</code></pre> <p></p> <p>The terminal should respond back with <code>Hello</code>. This will confirm that you have a working Terminal environment.</p> <p>A terminal environment is a text-based window where you type commands to communicate directly with a computer\u2019s operating system. Think of it as a simple interface\u2014no buttons or icons\u2014just typed instructions and responses. You'll need a terminal to work with Docker Compose, which is a tool for defining and running multi-container applications.</p> <p>Most distributions include a terminal by default.</p> <p>You can verify the terminal is working by running:</p> <pre><code>echo \"Hello World\"\n</code></pre> <p></p> <p>The terminal should respond back with <code>Hello</code>. This will confirm that you have a working Terminal environment.</p>"},{"location":"thoriumlxc/installation/#installing-docker","title":"Installing Docker","text":"Windows MacOS Ubuntu (Linux) <p>Follow these steps to install Docker Desktop on your Windows computer. This guide will help you through the process, even if you\u2019re not familiar with technical tools.</p> <p>When this has been completed, you should have an interface that looks something like this:</p> <p></p> <p>If you are able to see a screen like this, Docker is installed.</p> <p>Follow these steps to install Docker Desktop on your MacOS computer. This guide will help you through the process, even if you\u2019re not familiar with technical tools.</p> <p>When this has been completed, you should have an interface that looks something like this:</p> <p></p> <p>If you are able to see a screen like this, Docker is installed.</p> <p>Follow these steps to install Docker on your Linux computer. This guide will help you through the process, although it may be difficult if you are not familair with technical tools.</p> <p>If you encounter difficulties, following The Linux command line for beginners may help.</p> <p>When this has been completed, you should see something that looks like this in the terminal:</p> <p></p>"},{"location":"thoriumlxc/installation/#verifying-the-docker-installation","title":"Verifying the Docker Installation","text":"<p>Tip</p> <p>If you encounter issues while trying to setup Docker, you can review the troubleshooting processes to resolve the issues.</p> <p>Once Docker and a terminal is installed, you can verify the setup by running the \"Hello World\" container. This is a small test program packaged in Docker that runs a simple task: printing a confirmation message to show Docker is working correctly.</p> <p>Think of it like starting a new appliance for the first time to see if it powers on.</p> <p>Using the terminal from the previous step, type out (or  copy &amp; paste) the following text into the terminal</p> <pre><code>docker run hello-world\n</code></pre> <p>If the installation was successful, running this command should emit a message that looks like this:</p> <pre><code>$ docker run hello-world\nUnable to find image 'hello-world:latest' locally\nlatest: Pulling from library/hello-world\ne6590344b1a5: Download complete\nDigest: sha256:d715f14f9eca81473d9112df50457893aa4d099adeb4729f679006bf5ea12407\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n1. The Docker client contacted the Docker daemon.\n2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n    $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n    https://hub.docker.com/\n\nFor more examples and ideas, visit:\n    https://docs.docker.com/get-started/\n</code></pre> <p>The output should look similar to this</p> <p></p> <p>With the installation complete, you can return to the getting started guide to set up the deployment configurations.</p>"},{"location":"thoriumlxc/mangosd/","title":"CMangos Configuration Guide","text":""},{"location":"thoriumlxc/mangosd/#what-is-mangosdconf","title":"What is <code>mangosd.conf</code>?","text":"<p>The <code>mangosd.conf</code> file is the main configuration file for the CMangos server. It contains settings that control how the server operates, including server name, rates, logging, and more.</p> <p>Think of it as the \u201ccontrol center\u201d for your CMangos instance: if you need to tweak gameplay rates or connect to your database, you\u2019ll find the relevant settings here.</p>"},{"location":"thoriumlxc/mangosd/#example-using-mangosdconf-with-docker-compose","title":"Example: Using <code>mangosd.conf</code> with Docker Compose","text":"<p>Below is a basic example of how to mount the <code>mangosd.conf</code> file into a Docker Compose container. Replace the placeholder paths and image tags with your actual configuration:</p> <pre><code>version: '3.8'\nservices:\n  cmangos:\n    image: cmangos/server:latest\n    volumes:\n      - ./mangosd.conf:/etc/cmangos/mangosd.conf\n    ports:\n      - \"8085:8085\"\n    # Additional environment variables or configurations can go here\n</code></pre> <p>This works by working relative to the path of the <code>docker-compose.yaml</code> file. So if you file is located at <code>/some/path/to/file/docker-compose.yaml</code>, then your file would be next it within the same directory at <code>/some/path/to/file/mangosd.conf</code></p> <pre><code>-\n-\n-\n-\n</code></pre>"},{"location":"thoriumlxc/mangosd/#configuration-options","title":"Configuration Options","text":"<p>Here are a few commonly used settings from the <code>mangosd.conf</code> file. You can add more as needed:</p> <ul> <li><code>RealmID</code></li> <li> <p>A unique numeric identifier for your realm. If you have multiple realms, each needs a different ID.</p> </li> <li> <p><code>DataDir</code></p> </li> <li> <p>The file system path where your game data is stored. For example: <code>/usr/local/cmangos/data/</code></p> </li> <li> <p><code>WorldDatabaseInfo</code></p> </li> <li> <p>The connection details for your World database. Typically includes the host, port, username, password, and database name.   Example: <code>127.0.0.1;3306;root;password;cmangos_world</code></p> </li> <li> <p><code>Rates.Health</code></p> </li> <li> <p>Adjusts how quickly players regenerate health. A higher value means faster regeneration.</p> </li> <li> <p><code>Rates.DropMoney</code></p> </li> <li>Controls how much gold creatures drop. A lower value decreases dropped gold; a higher value increases it.</li> </ul> <p>Feel free to expand on these options or add new ones based on your project\u2019s needs. You can find more detailed documentation and community support in the official CMangos GitHub repository and forums.</p>"},{"location":"thoriumlxc/mariadb/","title":"MariaDB","text":"<p>MariaDB is an open-source database system, much like MySQL, and is used to store and manage data. In the context of CMangos, it acts as the backbone for storing game data, including characters, items, and world information.</p>"},{"location":"thoriumlxc/mariadb/#how-mariadb-fits-with-cmangos","title":"How MariaDB Fits with CMangos","text":"<p>MariaDB serves as the database backend for CMangos, storing all the persistent game data. CMangos communicates with MariaDB to retrieve and store this information, ensuring the game world operates smoothly and consistently.</p>"},{"location":"thoriumlxc/mariadb/#connection-details-in-cmangos","title":"Connection Details in CMangos","text":"<p>The connection between CMangos and MariaDB is defined in configuration files. These files include details like the database server address, user credentials, and database names, allowing CMangos to access and manage game data.</p>"},{"location":"thoriumlxc/mariadb/#managing-data-with-phpmyadmin","title":"Managing Data with phpMyAdmin","text":"<p>phpMyAdmin is a tool that provides a web interface for managing MariaDB databases. It allows you to view, edit, and manage the database contents without needing advanced technical skills. This can be particularly useful for making changes or troubleshooting the database.</p>"},{"location":"thoriumlxc/overview/","title":"ThoriumLXC","text":"<p>ThoriumLXC is an opinionated set of container images designed to run CMangos, VMangos, and similar projects within Docker containers.Container images are like packaged \u201cblueprints\u201d that include everything an application needs to run\u2014its code, system tools, and libraries. Instead of installing software on each machine and worrying about differences in settings, you can think of container images as self-contained boxes that work the same wherever they go.</p> <p>These images are opinionated, with the expectation to be running with Docker Compose.</p> <p>You can learn more about the design of these in Design.</p>"},{"location":"thoriumlxc/overview/#prerequisite-installation","title":"Prerequisite Installation","text":"<p>Before diving into any of the individual container images, you'll need to perform the prerequisite installation steps outlined in the Installation Guide. These steps are responsible for installing everything you'd need to be able to run one of the environments.</p>"},{"location":"thoriumlxc/overview/#project-configurations","title":"Project Configurations","text":"<p>ThoriumLXC makes downloadable git repositories available that provide the Docker configurations for running the emulation servers. Th</p> <p>It assumes that Docker and Docker Compose are already installed on your system, if you have not installed them yet, please visit the installation guide. All commands shown here should be typed into a Terminal.</p> <p>All of the downloadable git repositories will follow the file structure:</p> <pre><code>.\n\u251c\u2500\u2500 compose.yaml\n\u251c\u2500\u2500 mangosd.conf\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 realmd.conf\n</code></pre> <p>This will look like the following within the file system viewer for your operating system:</p>"},{"location":"thoriumlxc/overview/#downloading-the-project","title":"Downloading the Project","text":"<p>Tip</p> <p>This is an overview, if you are looking for a specific guide, navigate to the project page</p> <p>To get the files for this a docker compose setup, you will visit the repository on GitHub. Under the green \u201cCode\u201d button (or in the \u201cReleases\u201d section, if one is provided), you will see an option to download a ZIP archive of the code. Download and save the ZIP archive to a location on your computer, then extract its contents. You will end up with a folder that includes the <code>docker-compose.yml</code> file and other necessary files for the Mangos server.</p> <p>After extracting, open your Terminal or Command Prompt and navigate to the newly created folder. For instance, you could type something like:</p> <pre><code>cd /path/to/unzipped/folder\n</code></pre> <p>Adjust the command above to match the folder location where you extracted the archive. Once you are inside this folder, the Docker Compose commands explained in the rest of this document will apply.</p>"},{"location":"thoriumlxc/overview/#container-images","title":"Container Images","text":"<p>Note</p> <p>Each container image has instructions for installing the specific container image.</p> vMaNGOScMaNGOS ClassiccMaNGOS TBCcMaNGOS WOTLKAzerothCore <p> vMaNGOS is an open-source project devoted to accurately recreating an earlier era of a classic fantasy MMO. Building on established frameworks, it offers a stable environment for enthusiasts who want to explore, preserve, or customize the original game content, staying true to the core gameplay and features.</p> <p> cMaNGOS Classic is an open-source project focused on recreating the gameplay and world from a well-known classic fantasy MMO era. It provides a stable, community-driven environment for enthusiasts who want to preserve and explore earlier game mechanics. With its emphasis on authenticity, cMaNGOS-Classic ensures that the original content\u2014quests, zones, and core systems\u2014remain as accurate as possible to their roots.</p> <p> cMaNGOS TBC is an open-source project dedicated to preserving and recreating the second major era of a classic fantasy MMO. Building on the foundation of earlier versions, cMaNGOS TBC incorporates new zones, gameplay improvements, and additional features while maintaining authenticity and stability, allowing enthusiasts to experience the progression of content in its earlier form.</p> <p> cMaNGOS WOTLK is an open-source project focused on recreating the third major era of a classic fantasy MMO. It expands on the previous content with new zones, storyline developments, and updated mechanics, while maintaining accuracy and stability. This allows enthusiasts to explore and experience the progression and features introduced during this iconic period.</p> <p> AzerothCore is an open-source MMO server framework that aims to provide a robust, flexible, and actively maintained environment for creating and running your own game worlds. It supports a variety of features and expansions, offering a strong base for developers and communities to build upon and customize.</p>"},{"location":"thoriumlxc/realmd/","title":"realmd.conf Overview","text":"<p>The <code>realmd.conf</code> file is the primary configuration file for the authentication server in CMangos. It handles user logins and connections, specifying settings such as database connections, IP bindings, and security options.</p>"},{"location":"thoriumlxc/realmd/#example-configuration","title":"Example Configuration","text":"<p>To use <code>realmd.conf</code> with Docker Compose, you can create a custom configuration file and mount it into the Docker container:</p> <pre><code>version: '3'\nservices:\n  realmd:\n    image: cmangos/realmd\n    volumes:\n      - ./realmd.conf:/etc/cmangos/realmd.conf\n    ports:\n      - \"3724:3724\"\n</code></pre> <p>This works by working relative to the path of the <code>docker-compose.yaml</code> file. So if you file is located at <code>/some/path/to/file/docker-compose.yaml</code>, then your file would be next it within the same directory at <code>/some/path/to/file/realmd.conf</code></p> <pre><code>-\n-\n-\n-\n</code></pre>"},{"location":"thoriumlxc/realmd/#configuration-options","title":"Configuration Options","text":"<ul> <li><code>LoginDatabaseInfo</code>: Sets the database connection details for the authentication server.</li> <li><code>ListenHost</code>: Defines the IP address the server listens on.</li> <li><code>ListenPort</code>: Specifies the port for incoming connections.</li> <li><code>MaxPingTime</code>: Determines the maximum time to wait for client responses.</li> <li><code>LogLevel</code>: Controls the verbosity of logs for troubleshooting purposes. [media pointer=\"sediment://file_b3dac2fe39f0303c16a1c5ab521b4b49395159a8cb10a5b7ba7dcc96e8dcc9b1df462079404e2aa8e6e8de6740b5d9d4\"]</li> </ul>"},{"location":"thoriumlxc/build/building/","title":"Builder Image","text":"<p>The Builder Image is the core component responsible for compiling the CMangos server. It handles the entire build process, from source code to final binary artifacts, ensuring consistency and reliability across different environments.</p>"},{"location":"thoriumlxc/build/building/#what-is-the-builder-image","title":"What is the Builder Image?","text":"<p>The Builder Image:</p> <ul> <li>Runs the Build Process: Executes all steps required to compile CMangos.</li> <li>Includes a Specific Source Version: The source code is pre-baked into the image, ensuring version consistency.</li> <li>Relies on Build Deps: Uses fixed dependencies from the Build Deps image to maintain a stable build environment.</li> <li>Supports Customization: You can set environment variables or pass additional arguments when running the image with <code>docker run</code> to adjust the build process as needed.</li> </ul>"},{"location":"thoriumlxc/build/building/#running-the-builder-image","title":"Running the Builder Image","text":"<p>To build CMangos using the Builder Image, you can run:</p> <pre><code>docker run -e BUILD_OPTION=optimized mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <ul> <li><code>-e BUILD_OPTION=optimized</code> sets an environment variable that customizes the build.</li> <li><code>mockorg/cmangos-builder:2024.02.03-1</code> refers to the specific version of the Builder Image.</li> </ul> <p>After the build completes, the compiled artifacts are placed in an output directory inside the container. You can extract these artifacts by mounting a volume:</p> <pre><code>docker run -v $(pwd)/output:/output mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <p>This command saves the build results to your local <code>output</code> folder.</p>"},{"location":"thoriumlxc/build/building/#hermetic-builds-explained","title":"Hermetic Builds Explained","text":"<p>The Builder Image is designed to produce hermetic builds. But what does \"hermetic\" mean in this context?</p> <p>In simple terms:</p> <p>A hermetic build means that the build process is completely self-contained. It doesn\u2019t rely on anything outside of the Builder Image. This ensures that:</p> <ul> <li>Same Input = Same Output: No matter when or where you run the build, if the source code and settings are the same, the resulting binaries will be identical.</li> <li>No External Influence: The build isn\u2019t affected by your computer\u2019s settings, installed software, or even the current date and time.</li> <li>Predictable Results: Every build is like following a precise recipe\u2014no surprises.</li> </ul> <p>This is achieved by:</p> <ul> <li>Pre-baking the source code into the image.</li> <li>Using fixed dependencies from the Build Deps layer.</li> <li>Controlling the build environment strictly within Docker.</li> </ul>"},{"location":"thoriumlxc/build/building/#why-hermetic-builds-matter","title":"Why Hermetic Builds Matter","text":"<ul> <li>Consistency: Developers and users get the same results every time.</li> <li>Reliability: Easier to debug because there are no hidden variables affecting the build.</li> <li>Security: Reduces risks from external changes, like updates to system libraries or tools.</li> </ul>"},{"location":"thoriumlxc/build/building/#summary","title":"Summary","text":"<ul> <li>The Builder Image handles the full build process for CMangos.</li> <li>It uses pre-baked source code and fixed dependencies from the Build Deps image.</li> <li>You can customize builds with environment variables or arguments via <code>docker run</code>.</li> <li>Hermetic builds ensure that every build is consistent, reproducible, and reliable, no matter where or when it\u2019s run.</li> </ul>"},{"location":"thoriumlxc/build/deps/","title":"Build Deps","text":"<p>The CMangos Docker image architecture follows a modular approach, breaking down the build process into distinct layers for consistency, reproducibility, and maintainability. A critical part of this architecture is the Build Deps layer, which manages the foundational build dependencies required to compile the CMangos server.</p>"},{"location":"thoriumlxc/build/deps/#what-are-build-deps","title":"What are Build Deps?","text":"<p>Build Deps (short for Build Dependencies) refer to the essential system libraries, development tools, and other dependencies needed to build the CMangos project. These include:</p> <ul> <li>Standard Libraries (e.g., <code>libc</code>, <code>libssl</code>)</li> <li>Development Tools (e.g., <code>gcc</code>, <code>make</code>, <code>cmake</code>)</li> <li>Debian Packages required for compiling the source code</li> <li>Other system-level dependencies essential for the build process</li> </ul> <p>These dependencies are only used during the build phase and are not included in the final runtime image, keeping the production environment clean and lightweight.</p>"},{"location":"thoriumlxc/build/deps/#deterministic-builds-with-bazel-and-rules-oci","title":"Deterministic Builds with Bazel and Rules OCI","text":"<p>To ensure that builds are deterministic\u2014meaning the same source code always produces the same output\u2014we use Bazel along with Rules OCI. This combination offers several advantages:</p> <ul> <li>Reproducibility: Regardless of when or where the build occurs, the output will be identical if the source code version remains the same.</li> <li>Version Control: Build dependencies are pinned to specific versions, eliminating inconsistencies from upstream package changes.</li> <li>Efficiency: Bazel\u2019s caching and precise dependency management speed up rebuilds, especially for minor changes.</li> </ul> <p>By leveraging Bazel and Rules OCI, we eliminate variables that could affect build outcomes, ensuring reliable results across development, testing, and production environments.</p>"},{"location":"thoriumlxc/build/deps/#the-builder-image","title":"The Builder Image","text":"<p>The Builder image builds on top of the Build Deps layer. It contains everything required to compile the CMangos server, including:</p> <ul> <li>Pre-installed Build Deps: All necessary libraries and tools for building the source code.</li> <li>Build Scripts and Steps: Automated processes baked into the image to handle compilation.</li> <li>Environment Variables: Configurations required during the build process.</li> <li>Upstream Source Code: Integrated directly from official repositories for clean, version-controlled builds.</li> </ul> <p>The Builder image is solely responsible for the build process. It does not include runtime components, keeping it focused and optimized for its purpose.</p>"},{"location":"thoriumlxc/build/deps/#how-it-all-fits-together","title":"How It All Fits Together","text":"<ol> <li>Build Deps Layer: Provides the foundational dependencies required to build CMangos.</li> <li>Builder Image: Utilizes the Build Deps layer to compile the server code and manage build configurations.</li> <li>Final Runtime Image: Contains only the compiled binaries and runtime dependencies, optimized for performance and minimal size.</li> </ol> <p>This layered architecture allows for greater flexibility, easier updates, and improved security by separating build tools from the final production environment.</p>"},{"location":"thoriumlxc/build/deps/#summary","title":"Summary","text":"<ul> <li>Build Deps manage the critical dependencies required for building CMangos.</li> <li>Dependencies are installed using Bazel and Rules OCI for deterministic, reproducible builds.</li> <li>The Builder Image leverages Build Deps to execute build steps, manage environment variables, and integrate upstream source code.</li> <li>This modular design ensures clean, consistent builds and optimized runtime environments.</li> </ul>"},{"location":"thoriumlxc/build/overview/","title":"High-Level Overview of the Image Build Pattern","text":"<p>The CMangos server is packaged using a carefully designed build pattern that ensures consistency, reliability, and ease of deployment. This pattern breaks the build process into distinct stages, with each stage focusing on a specific part of the process. By separating the build into layers, we can create clean, efficient, and predictable server images that are easy to manage and update.</p> <p>Think of this process like baking a cake:</p> <ul> <li>You gather your ingredients (dependencies).</li> <li>Mix and bake the cake (build the server).</li> <li>Remove the baking tools (runtime environment).</li> <li>Add the final decorations and packaging (final image ready to serve).</li> </ul> <p>Here\u2019s how this pattern works for CMangos:</p> <pre><code>flowchart TD\n    A[Build Deps Image] --&gt; B[Builder Image]\n    B --&gt;|Build Artifacts| D[Final Image]\n    C[Runtime Image] --&gt;|Runtime Dependencies| D\n\n    D --&gt; E[Deployment]\n\n    classDef deps stroke-width:2px;\n    classDef builder stroke-width:2px;\n    classDef runtime stroke-width:2px;\n    classDef final stroke-width:2px;\n\n    class A deps;\n    class B builder;\n    class C runtime;\n    class D final;\n</code></pre>"},{"location":"thoriumlxc/build/overview/#the-four-layers-of-the-build-pattern","title":"The Four Layers of the Build Pattern","text":"<ol> <li> <p>Build Deps (Build Dependencies) Image    Think of this as your pantry of ingredients.    This image contains all the tools, libraries, and system packages needed to build the CMangos server. It includes things like compilers, standard libraries, and other software required to turn the source code into a working program.</p> </li> <li> <p>Purpose: Provides the foundation for the build process.</p> </li> <li> <p>Key Point: It\u2019s not part of the final server. It\u2019s only used to help \"mix the ingredients.\"</p> </li> <li> <p>Builder Image    This is like the kitchen where you prepare the cake.    The Builder Image takes the source code and, using the tools from the Build Deps image, compiles it into working server binaries (the actual program files that run the game server).</p> </li> <li> <p>Purpose: Runs the build process, producing the final server files.</p> </li> <li> <p>Key Point: Includes a specific version of the source code, ensuring the same result every time.</p> </li> <li> <p>Runtime Image    Now the cake is baked, and you\u2019ve cleaned up the kitchen. Only the cake remains.    The Runtime Image is a clean, minimal environment that contains only the files and libraries needed to run the server\u2014nothing extra. All the build tools and unnecessary files are left behind.</p> </li> <li> <p>Purpose: Provides the environment where the CMangos server will run.</p> </li> <li> <p>Key Point: Smaller, faster, and more secure because it doesn\u2019t include unnecessary tools.</p> </li> <li> <p>Final Image    This is the beautifully decorated cake, ready to serve.    The Final Image combines the Runtime Image with the built server files from the Builder Image and adds any necessary configuration files. This is the image you\u2019ll actually deploy to run your CMangos server.</p> </li> <li> <p>Purpose: The complete, deployable server image.</p> </li> <li>Key Point: Contains everything needed to run CMangos in production.</li> </ol>"},{"location":"thoriumlxc/build/overview/#why-this-pattern-matters","title":"Why This Pattern Matters","text":"<ul> <li>Consistency: Every time you build the server, you get the same result\u2014no surprises.</li> <li>Security: By removing unnecessary tools and files, the final image is more secure.</li> <li>Efficiency: Smaller images mean faster deployment and less resource usage.</li> <li>Reproducibility: Builds are deterministic, meaning the same source code always produces the same output.</li> </ul>"},{"location":"thoriumlxc/build/runtime/","title":"Runtime Image","text":"<p>The Runtime Image is the final, deployable container that runs the CMangos server. It is designed to be lightweight, secure, and optimized for performance, containing only the essential components needed to run the server.</p>"},{"location":"thoriumlxc/build/runtime/#what-is-the-runtime-image","title":"What is the Runtime Image?","text":"<p>The Runtime Image:</p> <ul> <li>Contains Only Runtime Dependencies: Unlike the Build Deps image, which includes tools needed for compiling code, the Runtime Image includes just the libraries and packages required for CMangos to function.</li> <li>Packages Built Binaries: The compiled server binaries from the Builder Image are packaged into the Runtime Image.</li> <li>Optimized for Efficiency: By excluding unnecessary build tools and dependencies, the image is smaller and more secure.</li> </ul>"},{"location":"thoriumlxc/build/runtime/#how-the-runtime-image-is-built","title":"How the Runtime Image is Built","text":"<p>The process to create the Runtime Image involves:</p> <ol> <li>Using the Build Deps Model: Similar to the Build Deps image, the Runtime Image is created with fixed, deterministic dependencies to ensure consistency.</li> <li>Packaging Binaries: The built server binaries are copied from the Builder Image into the Runtime Image.</li> <li>Stripping Down the Environment: Any unnecessary files, build tools, or extra data are excluded to keep the image lean.</li> </ol> <p>This results in a minimal container that contains everything needed to run the CMangos server\u2014nothing more, nothing less.</p>"},{"location":"thoriumlxc/build/runtime/#benefits-of-the-runtime-image","title":"Benefits of the Runtime Image","text":"<ul> <li>Smaller Size: Reduces resource usage, making it faster to deploy and more efficient to run.</li> <li>Improved Security: Fewer components mean fewer potential vulnerabilities.</li> <li>Consistency: Built using deterministic methods, ensuring the same runtime environment across all deployments.</li> </ul>"},{"location":"thoriumlxc/build/runtime/#running-the-runtime-image","title":"Running the Runtime Image","text":"<p>Once the Runtime Image is built, you can run it like any standard Docker container:</p> <pre><code>docker run -p 8085:8085 -p 3724:3724 mockorg/cmangos-runtime:2024.02.03-1\n</code></pre> <ul> <li>Ports 8085 and 3724 are exposed for the game server and login server.</li> <li><code>mockorg/cmangos-runtime:2024.02.03-1</code> refers to the specific version of the Runtime Image.</li> </ul> <p>For persistent data (like database storage or logs), you can mount volumes:</p> <pre><code>docker run -v $(pwd)/data:/data mockorg/cmangos-runtime:2024.02.03-1\n</code></pre>"},{"location":"thoriumlxc/build/runtime/#summary","title":"Summary","text":"<ul> <li>The Runtime Image is the final container that runs CMangos, containing only the dependencies needed for runtime.</li> <li>It is built using deterministic methods, similar to the Build Deps image, ensuring consistent, reliable performance.</li> <li>The image packages the built binaries from the Builder Image, creating a clean, minimal environment optimized for deployment.</li> <li>This approach enhances security, reduces resource usage, and simplifies server management.</li> </ul>"},{"location":"thoriumlxc/database/backups/","title":"Database Backups","text":"<p>When using Docker Compose with Docker and MariaDB, you can create a simple setup for database backups. Essentially, Docker Compose helps manage multi-container applications, and MariaDB is the database server. To back up the database, you'll use a tool like <code>mysqldump</code>, which is commonly used for creating backups of MySQL/MariaDB databases.</p>"},{"location":"thoriumlxc/database/backups/#docker-compose-example","title":"Docker Compose Example","text":"<p>Let's create a <code>docker-compose.yml</code> file with two main services: the MariaDB server and a backup service.</p> <pre><code>version: '3.8'\nservices:\n  mariadb:\n    image: mariadb:latest\n    environment:\n      MARIADB_ROOT_PASSWORD: example_password\n      MARIADB_DATABASE: example_db\n    volumes:\n      - db_data:/var/lib/mysql\n\n  backup:\n    image: mariadb:latest\n    volumes:\n      - db_data:/var/lib/mysql\n      - ./backups:/backups\n    command: &gt;\n      bash -c \"mysqldump -uroot -pexample_password example_db &gt; /backups/backup.sql\"\n\nvolumes:\n  db_data:\n    driver: local\n</code></pre>"},{"location":"thoriumlxc/database/backups/#explanation-of-example","title":"Explanation of Example","text":"<ol> <li>MariaDB Service:</li> <li>This service (<code>mariadb</code>) runs a MariaDB container.</li> <li><code>MARIADB_ROOT_PASSWORD</code> sets the root password for the database.</li> <li><code>MARIADB_DATABASE</code> creates a new database named <code>example_db</code>.</li> <li> <p>The volume <code>db_data</code> persists the database data.</p> </li> <li> <p>Backup Service:</p> </li> <li>This service (<code>backup</code>) uses the same image as MariaDB to use the <code>mysqldump</code> tool.</li> <li>It mounts the <code>db_data</code> volume to access the database files.</li> <li>It also mounts a <code>./backups</code> folder from the host to store backups.</li> <li>The <code>command</code> field uses <code>mysqldump</code> to export the database to a file named <code>backup.sql</code> inside the <code>backups</code> folder.</li> </ol>"},{"location":"thoriumlxc/design/overview/","title":"Overview","text":"<p>ThoriumLXC is a project focused on providing container images that can be used to spin up cMaNGOS/vMaNGOS server environments without needing to modify the base OS.</p>"},{"location":"thoriumlxc/design/overview/#docker","title":"Docker","text":"<p>Docker is a tool that packages software into self-contained \u201ccontainers,\u201d which include everything needed to run an application\u2014its libraries, tools, and any system dependencies. You can think of each container as a portable box that remains the same regardless of where it\u2019s opened. This consistency makes it easier to avoid those frustrating moments where something works on one computer but not another.</p> <p>By relying on Docker, setting up software becomes more straightforward because you only need to pull the container instead of installing several tools by hand. Updates are also simpler: if a new version of the application is released, you just download the latest container, which helps you avoid the messy cleanup or leftover files that sometimes occur with traditional upgrade processes. Similarly, fixing misconfigurations is less of a headache because you can remove a troublesome container entirely and start fresh.</p> <p>I chose Docker for ThoriumLXC because it simplfied spinning up and down servers in my homeserver. Using different Docker Compose files allowed managing different server versions without worrying about the base OS libraries (e.g. libmysqlclient). Plus, it provided a great opportunity to experiment with building container images, and patterns like the BuildDeps, Builder, Runtime and Final images.</p>"},{"location":"thoriumlxc/design/overview/#docker-compose","title":"Docker Compose","text":"<p>When a project depends on several containers, Docker Compose ensures they all work together smoothly. Rather than juggling multiple commands or manually wiring each container to the right place, you can define the entire setup in a single file. This configuration tells Docker exactly which containers you need, how they communicate with one another, and any resources they need to share. In this sense, Docker Compose acts like a coordinator, launching and managing all the containers at once, so you can focus on the actual application instead of spending time on the underlying infrastructure.</p>"},{"location":"thoriumlxc/design/overview/#bazel","title":"Bazel","text":"<p>I opted for Bazel in this project primarily to explore <code>rules_oci</code>, which offered a more refined approach compared to the earlier <code>rules_docker</code>. The previous ruleset had challenges with unexpected behaviors and complex internals (go dependencies), making it cumbersome in a number of ways.</p> <p>In contrast, <code>rules_oci</code> promised a simplified, streamlined interface as it dropped support for things like <code>container_run_and_extract</code>, and other rules that added a lot of dependency to them. When building with <code>rules_oci</code>, I inteneded up taking the approach of the build-deps, builder, runtime, and final image pattern as I felt it allowed me to leverage <code>docker run</code>, while still orchestrating everything with Bazel.</p> <p>The potential for hermetic builds is nice as well, as it meant that the same source code always produced bit-wise identical images.</p>"},{"location":"vmangos/client-data/","title":"Client Data","text":""},{"location":"vmangos/clients/","title":"Supported Clients","text":"<p>Supported Clients</p>"},{"location":"vmangos/installation/","title":"Installing cMaNGOS Classic","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"vmangos/installation/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"vmangos/installation/#sample-title","title":"Sample Title","text":"<p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Ctrl+Alt+Del</p>"},{"location":"vmangos/installation/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"vmangos/overview/","title":"Getting Started with cMaNGOS Classic","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"vmangos/overview/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"vmangos/overview/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"vmangos/versions/","title":"Versions","text":"<p>Versions</p>"},{"location":"vmangos/bots/ahbot/","title":"AH Bots","text":""},{"location":"vmangos/bots/playerbots/","title":"Playerbots","text":""},{"location":"vmangos/build/building/","title":"Builder Image","text":"<p>The Builder Image is the core component responsible for compiling the CMangos server. It handles the entire build process, from source code to final binary artifacts, ensuring consistency and reliability across different environments.</p>"},{"location":"vmangos/build/building/#what-is-the-builder-image","title":"What is the Builder Image?","text":"<p>The Builder Image:</p> <ul> <li>Runs the Build Process: Executes all steps required to compile CMangos.</li> <li>Includes a Specific Source Version: The source code is pre-baked into the image, ensuring version consistency.</li> <li>Relies on Build Deps: Uses fixed dependencies from the Build Deps image to maintain a stable build environment.</li> <li>Supports Customization: You can set environment variables or pass additional arguments when running the image with <code>docker run</code> to adjust the build process as needed.</li> </ul>"},{"location":"vmangos/build/building/#running-the-builder-image","title":"Running the Builder Image","text":"<p>To build CMangos using the Builder Image, you can run:</p> <pre><code>docker run -e BUILD_OPTION=optimized mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <ul> <li><code>-e BUILD_OPTION=optimized</code> sets an environment variable that customizes the build.</li> <li><code>mockorg/cmangos-builder:2024.02.03-1</code> refers to the specific version of the Builder Image.</li> </ul> <p>After the build completes, the compiled artifacts are placed in an output directory inside the container. You can extract these artifacts by mounting a volume:</p> <pre><code>docker run -v $(pwd)/output:/output mockorg/cmangos-builder:2024.02.03-1\n</code></pre> <p>This command saves the build results to your local <code>output</code> folder.</p>"},{"location":"vmangos/build/building/#hermetic-builds-explained","title":"Hermetic Builds Explained","text":"<p>The Builder Image is designed to produce hermetic builds. But what does \"hermetic\" mean in this context?</p> <p>In simple terms:</p> <p>A hermetic build means that the build process is completely self-contained. It doesn\u2019t rely on anything outside of the Builder Image. This ensures that:</p> <ul> <li>Same Input = Same Output: No matter when or where you run the build, if the source code and settings are the same, the resulting binaries will be identical.</li> <li>No External Influence: The build isn\u2019t affected by your computer\u2019s settings, installed software, or even the current date and time.</li> <li>Predictable Results: Every build is like following a precise recipe\u2014no surprises.</li> </ul> <p>This is achieved by:</p> <ul> <li>Pre-baking the source code into the image.</li> <li>Using fixed dependencies from the Build Deps layer.</li> <li>Controlling the build environment strictly within Docker.</li> </ul>"},{"location":"vmangos/build/building/#why-hermetic-builds-matter","title":"Why Hermetic Builds Matter","text":"<ul> <li>Consistency: Developers and users get the same results every time.</li> <li>Reliability: Easier to debug because there are no hidden variables affecting the build.</li> <li>Security: Reduces risks from external changes, like updates to system libraries or tools.</li> </ul>"},{"location":"vmangos/build/building/#summary","title":"Summary","text":"<ul> <li>The Builder Image handles the full build process for CMangos.</li> <li>It uses pre-baked source code and fixed dependencies from the Build Deps image.</li> <li>You can customize builds with environment variables or arguments via <code>docker run</code>.</li> <li>Hermetic builds ensure that every build is consistent, reproducible, and reliable, no matter where or when it\u2019s run.</li> </ul>"},{"location":"vmangos/build/deps/","title":"Build Deps","text":"<p>The CMangos Docker image architecture follows a modular approach, breaking down the build process into distinct layers for consistency, reproducibility, and maintainability. A critical part of this architecture is the Build Deps layer, which manages the foundational build dependencies required to compile the CMangos server.</p>"},{"location":"vmangos/build/deps/#what-are-build-deps","title":"What are Build Deps?","text":"<p>Build Deps (short for Build Dependencies) refer to the essential system libraries, development tools, and other dependencies needed to build the CMangos project. These include:</p> <ul> <li>Standard Libraries (e.g., <code>libc</code>, <code>libssl</code>)</li> <li>Development Tools (e.g., <code>gcc</code>, <code>make</code>, <code>cmake</code>)</li> <li>Debian Packages required for compiling the source code</li> <li>Other system-level dependencies essential for the build process</li> </ul> <p>These dependencies are only used during the build phase and are not included in the final runtime image, keeping the production environment clean and lightweight.</p>"},{"location":"vmangos/build/deps/#deterministic-builds-with-bazel-and-rules-oci","title":"Deterministic Builds with Bazel and Rules OCI","text":"<p>To ensure that builds are deterministic\u2014meaning the same source code always produces the same output\u2014we use Bazel along with Rules OCI. This combination offers several advantages:</p> <ul> <li>Reproducibility: Regardless of when or where the build occurs, the output will be identical if the source code version remains the same.</li> <li>Version Control: Build dependencies are pinned to specific versions, eliminating inconsistencies from upstream package changes.</li> <li>Efficiency: Bazel\u2019s caching and precise dependency management speed up rebuilds, especially for minor changes.</li> </ul> <p>By leveraging Bazel and Rules OCI, we eliminate variables that could affect build outcomes, ensuring reliable results across development, testing, and production environments.</p>"},{"location":"vmangos/build/deps/#the-builder-image","title":"The Builder Image","text":"<p>The Builder image builds on top of the Build Deps layer. It contains everything required to compile the CMangos server, including:</p> <ul> <li>Pre-installed Build Deps: All necessary libraries and tools for building the source code.</li> <li>Build Scripts and Steps: Automated processes baked into the image to handle compilation.</li> <li>Environment Variables: Configurations required during the build process.</li> <li>Upstream Source Code: Integrated directly from official repositories for clean, version-controlled builds.</li> </ul> <p>The Builder image is solely responsible for the build process. It does not include runtime components, keeping it focused and optimized for its purpose.</p>"},{"location":"vmangos/build/deps/#how-it-all-fits-together","title":"How It All Fits Together","text":"<ol> <li>Build Deps Layer: Provides the foundational dependencies required to build CMangos.</li> <li>Builder Image: Utilizes the Build Deps layer to compile the server code and manage build configurations.</li> <li>Final Runtime Image: Contains only the compiled binaries and runtime dependencies, optimized for performance and minimal size.</li> </ol> <p>This layered architecture allows for greater flexibility, easier updates, and improved security by separating build tools from the final production environment.</p>"},{"location":"vmangos/build/deps/#summary","title":"Summary","text":"<ul> <li>Build Deps manage the critical dependencies required for building CMangos.</li> <li>Dependencies are installed using Bazel and Rules OCI for deterministic, reproducible builds.</li> <li>The Builder Image leverages Build Deps to execute build steps, manage environment variables, and integrate upstream source code.</li> <li>This modular design ensures clean, consistent builds and optimized runtime environments.</li> </ul>"},{"location":"vmangos/build/overview/","title":"High-Level Overview of the Image Build Pattern","text":"<p>The CMangos server is packaged using a carefully designed build pattern that ensures consistency, reliability, and ease of deployment. This pattern breaks the build process into distinct stages, with each stage focusing on a specific part of the process. By separating the build into layers, we can create clean, efficient, and predictable server images that are easy to manage and update.</p> <p>Think of this process like baking a cake:</p> <ul> <li>You gather your ingredients (dependencies).</li> <li>Mix and bake the cake (build the server).</li> <li>Remove the baking tools (runtime environment).</li> <li>Add the final decorations and packaging (final image ready to serve).</li> </ul> <p>Here\u2019s how this pattern works for CMangos:</p> <pre><code>flowchart TD\n    A[Build Deps Image] --&gt; B[Builder Image]\n    B --&gt;|Build Artifacts| D[Final Image]\n    C[Runtime Image] --&gt;|Runtime Dependencies| D\n\n    D --&gt; E[Deployment]\n\n    classDef deps stroke-width:2px;\n    classDef builder stroke-width:2px;\n    classDef runtime stroke-width:2px;\n    classDef final stroke-width:2px;\n\n    class A deps;\n    class B builder;\n    class C runtime;\n    class D final;\n</code></pre>"},{"location":"vmangos/build/overview/#the-four-layers-of-the-build-pattern","title":"The Four Layers of the Build Pattern","text":"<ol> <li> <p>Build Deps (Build Dependencies) Image    Think of this as your pantry of ingredients.    This image contains all the tools, libraries, and system packages needed to build the CMangos server. It includes things like compilers, standard libraries, and other software required to turn the source code into a working program.</p> </li> <li> <p>Purpose: Provides the foundation for the build process.</p> </li> <li> <p>Key Point: It\u2019s not part of the final server. It\u2019s only used to help \"mix the ingredients.\"</p> </li> <li> <p>Builder Image    This is like the kitchen where you prepare the cake.    The Builder Image takes the source code and, using the tools from the Build Deps image, compiles it into working server binaries (the actual program files that run the game server).</p> </li> <li> <p>Purpose: Runs the build process, producing the final server files.</p> </li> <li> <p>Key Point: Includes a specific version of the source code, ensuring the same result every time.</p> </li> <li> <p>Runtime Image    Now the cake is baked, and you\u2019ve cleaned up the kitchen. Only the cake remains.    The Runtime Image is a clean, minimal environment that contains only the files and libraries needed to run the server\u2014nothing extra. All the build tools and unnecessary files are left behind.</p> </li> <li> <p>Purpose: Provides the environment where the CMangos server will run.</p> </li> <li> <p>Key Point: Smaller, faster, and more secure because it doesn\u2019t include unnecessary tools.</p> </li> <li> <p>Final Image    This is the beautifully decorated cake, ready to serve.    The Final Image combines the Runtime Image with the built server files from the Builder Image and adds any necessary configuration files. This is the image you\u2019ll actually deploy to run your CMangos server.</p> </li> <li> <p>Purpose: The complete, deployable server image.</p> </li> <li>Key Point: Contains everything needed to run CMangos in production.</li> </ol>"},{"location":"vmangos/build/overview/#why-this-pattern-matters","title":"Why This Pattern Matters","text":"<ul> <li>Consistency: Every time you build the server, you get the same result\u2014no surprises.</li> <li>Security: By removing unnecessary tools and files, the final image is more secure.</li> <li>Efficiency: Smaller images mean faster deployment and less resource usage.</li> <li>Reproducibility: Builds are deterministic, meaning the same source code always produces the same output.</li> </ul>"},{"location":"vmangos/build/runtime/","title":"Runtime Image","text":"<p>The Runtime Image is the final, deployable container that runs the CMangos server. It is designed to be lightweight, secure, and optimized for performance, containing only the essential components needed to run the server.</p>"},{"location":"vmangos/build/runtime/#what-is-the-runtime-image","title":"What is the Runtime Image?","text":"<p>The Runtime Image:</p> <ul> <li>Contains Only Runtime Dependencies: Unlike the Build Deps image, which includes tools needed for compiling code, the Runtime Image includes just the libraries and packages required for CMangos to function.</li> <li>Packages Built Binaries: The compiled server binaries from the Builder Image are packaged into the Runtime Image.</li> <li>Optimized for Efficiency: By excluding unnecessary build tools and dependencies, the image is smaller and more secure.</li> </ul>"},{"location":"vmangos/build/runtime/#how-the-runtime-image-is-built","title":"How the Runtime Image is Built","text":"<p>The process to create the Runtime Image involves:</p> <ol> <li>Using the Build Deps Model: Similar to the Build Deps image, the Runtime Image is created with fixed, deterministic dependencies to ensure consistency.</li> <li>Packaging Binaries: The built server binaries are copied from the Builder Image into the Runtime Image.</li> <li>Stripping Down the Environment: Any unnecessary files, build tools, or extra data are excluded to keep the image lean.</li> </ol> <p>This results in a minimal container that contains everything needed to run the CMangos server\u2014nothing more, nothing less.</p>"},{"location":"vmangos/build/runtime/#benefits-of-the-runtime-image","title":"Benefits of the Runtime Image","text":"<ul> <li>Smaller Size: Reduces resource usage, making it faster to deploy and more efficient to run.</li> <li>Improved Security: Fewer components mean fewer potential vulnerabilities.</li> <li>Consistency: Built using deterministic methods, ensuring the same runtime environment across all deployments.</li> </ul>"},{"location":"vmangos/build/runtime/#running-the-runtime-image","title":"Running the Runtime Image","text":"<p>Once the Runtime Image is built, you can run it like any standard Docker container:</p> <pre><code>docker run -p 8085:8085 -p 3724:3724 mockorg/cmangos-runtime:2024.02.03-1\n</code></pre> <ul> <li>Ports 8085 and 3724 are exposed for the game server and login server.</li> <li><code>mockorg/cmangos-runtime:2024.02.03-1</code> refers to the specific version of the Runtime Image.</li> </ul> <p>For persistent data (like database storage or logs), you can mount volumes:</p> <pre><code>docker run -v $(pwd)/data:/data mockorg/cmangos-runtime:2024.02.03-1\n</code></pre>"},{"location":"vmangos/build/runtime/#summary","title":"Summary","text":"<ul> <li>The Runtime Image is the final container that runs CMangos, containing only the dependencies needed for runtime.</li> <li>It is built using deterministic methods, similar to the Build Deps image, ensuring consistent, reliable performance.</li> <li>The image packages the built binaries from the Builder Image, creating a clean, minimal environment optimized for deployment.</li> <li>This approach enhances security, reduces resource usage, and simplifies server management.</li> </ul>"},{"location":"vmangos/config/accounts/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"vmangos/config/commands/","title":"Accounts","text":"<p>Accounts</p>"},{"location":"vmangos/config/mangosd/","title":"Mangosd","text":""},{"location":"vmangos/config/mariadb/","title":"MariaDB","text":""},{"location":"vmangos/config/realmd/","title":"RealmD","text":""}]}